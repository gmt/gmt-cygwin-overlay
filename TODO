o The profile should be reparented at some point so that the
  paths are compatible with a default layman installation

o It turns out that the CHOST setting I have used is an historical
  relic that makes no sense.  I don't know why I didn't figure this
  out sooner; anyhow, instead of 

    CHOST="i686-pc-cygwin1.7"

  we can just have

    CHOST="i686-pc-cygwin"

  and all the various work-arounds in this overlay pertaining to "1.7"
  -- mostly various patches changing bash case statements from, i.e.:

    - *-foo*|*-bar*|*-cygwin|*-baz*)
    + *-foo*|*-bar*|*-cygwin*|*-baz*)

  -- can be abandoned.  yay!  Unfortunately, doing so is going to pretty
  much fsck up my half-completed bootstrap process and I'm too lazy/entrenched
  to comfortably do so just yet.  So for now I guess I am stuck with it.  boo!

o When directly merging a formerly cygdll_protected file, we should wipe out
  any in-limbo files -- otherwise the administrator with automatically revert
  to some older version when they run cygdll-update!!!  This means we need to
  check the cygdlldict for every regular file that is merged.
  
o Some thought will eventually need to be put into just how big the cygdll
  protections database is going to get.  If its getting out of hand, we might
  consider embedded mysql or something.  The cygdll protections db is flushed
  much more frequently than the configdb and potentially could get large if
  someone is running big emerges (but wouldn't this cause breakage anyhow
  due to bad BDEPs?)... something to keep an eye on anyhow.

o Somehow we want to get rid of ultra-prefixify, it is a horrible abomination.
  One approach would be to build our own cygwin DLL and launcher utility
  (to ensure that no other cygwin DLL gets pulled in).  Armed with
  a cygwin1.dll ebuild (+ whatever else is in cygwin base package),
  we could put in some prefixification patches to avoid i.e. /bin/sh and
  redirect to EPREFIX.

o libtool patches for fork/subshell avoidance

o fix libtool-2.4.2.ebuild to be merely horrible instead of satanically,
  rediculously, unspeakably gross.

o Need to determine: will cygwin load a .dll through a symlink?  or only respect
  binaries in PATH?  Basically: Does ignoring symlinks open us up to problems
  as users, and should we therefore support tracking them with cygdll-protect?
  Even if there's no issue there in cygwin, I feel like it's awfully
  platform-kludgetastic to ignore them.  As of now, they are ignored,
  completely, even if you name them explicitly in CYGDLL_PROTECT.

o manpage entries about the items we added to EPREFIX/var/lib/portage

o cygdll-update needs to understand the empty-file-hash convention or else
  it's pointless

o Clearly absolute paths are not the answer for cygdll-protect.  Either
  implement a kludge like "dll's get their paths stripped for testing
  is_cygdll_protected" or something more generally useful like regular
  expression matching (substututions?) I still wasn't convinced we need this
  until I realized what happens when you move a dll around from version a->b
  of an ebuild -- it's back to the same old BS rebase issues again; there's no
  reason to let continue after building all this infrastructure to prevent it.

o It is desirable for as many portage components as possible to register themselves
  with the master lock, including ebuild.sh and really anything we can figure out
  will be running in a subshell.  However, to do this correctly we are going to need
  to back down from the existing assumption that the master lock cannot be acquired
  while a non-portage process is waiting for it; some kind of mode needs to be
  introduced that will allow exactly that to happen.

o Even though they are not allowed in the CYGDLL_PROTECT variable, it would be nice
  if cygdll-update was able to handle filenames with spaces in them (as of now this
  will have undefined results).

o Furthermore, during the phase of cygdll-update where the files are being merged
  to the filesystem, we should do everything possible to avoid subshells and relying
  on external executables.  What's there now was borrowed from etc-update and
  doesn't do this at all.  There is code in libtool that we could use for this
  although I'd need to think about whether there are any licensing issues if we
  use that (i.e.: quote_for_eval, etc).  The issue, of course, is that if
  cygdll_update is itself prone to rebasing problems the user could get pretty
  screwed.

o If cygdll_protected files are in "removed-in-limbo" state (that is, the file
  is present in cygdll database with the null md5 and has not been physically
  removed), then if a package is merged that wants to create this file, and
  collision-protect is active, then the merge will fail as there is no exception
  made in the collision-protect code against it.  Also, if protect-if-owned is
  active, then the long database search that happens for collisions will eventually
  occur (although, presumably, the merge will succeed in this case).

  Both of these cases require an exception.  Instead of normal collision behavior,
  the merge should instantly succeed, the file should be installed as the
  currently non-existent _cygdll_protect_foo.dll or whatever, and the new md5
  of the merged file should replace the null md5 which is currently in the
  cygdll database.

o Cygdll-update currently silently discards CYGDLL_UPDATE settings which do not
  currently exist in the filesystem -- but this breaks cygdll protection for
  new files which may conflict with old files that are elsewhere.  The non-existence
  test should simply be removed
