o The profile should be reparented at some point so that the
  paths are compatible with a default layman installation

o It turns out that the CHOST setting I have used is an historical
  relic that makes no sense.  I don't know why I didn't figure this
  out sooner; anyhow, instead of 

    CHOST="i686-pc-cygwin1.7"

  we can just have

    CHOST="i686-pc-cygwin"

  and all the various work-arounds in this overlay pertaining to "1.7"
  -- mostly various patches changing bash case statements from, i.e.:

    - *-foo*|*-bar*|*-cygwin|*-baz*)
    + *-foo*|*-bar*|*-cygwin*|*-baz*)

  -- can be abandoned.  yay!  Unfortunately, doing so is going to pretty
  much fsck up my half-completed bootstrap process and I'm too lazy/entrenched
  to comfortably do so just yet.  So for now I guess I am stuck with it.  boo!

o Somehow we want to get rid of ultra-prefixify, it is a horrible abomination.
  One approach would be to build our own cygwin DLL and launcher utility
  (to ensure that no other cygwin DLL gets pulled in).  Armed with
  a cygwin1.dll ebuild (+ whatever else is in cygwin base package),
  we could put in some prefixification patches to avoid i.e. /bin/sh and
  redirect to EPREFIX.

o libtool patches for fork/subshell avoidance

o fix libtool-2.4.2.ebuild to be merely horrible instead of satanically,
  rediculously, unspeakably gross.

o Need to determine: will cygwin load a .dll through a symlink?  or only respect
  binaries in PATH?  Basically: Does ignoring symlinks open us up to problems
  as users, and should we therefore support tracking them with cygdll-protect?
  Even if there's no issue there in cygwin, I feel like it's awfully
  platform-kludgetastic to ignore them.  As of now, they are ignored,
  completely, even if you name them explicitly in CYGDLL_PROTECT.

o manpage entries about the items we added to EPREFIX/var/lib/portage

o Clearly absolute paths are not the (full) answer for cygdll-protect.  Either
  implement a kludge like "dll's get their paths stripped for testing
  is_cygdll_protected" or something more generally useful like regular
  expression matching (substututions?) I still wasn't convinced we need this
  until I realized what happens when you move a dll around from version a->b
  of an ebuild -- it's back to the same old BS rebase issues again; there's no
  reason to let continue after building all this infrastructure to prevent it.

o It is desirable for as many portage components as possible to register themselves
  with the master lock, including ebuild.sh and really anything we can figure out
  will be running under the care of portage.  However, to do this correctly we are
  going to need to back down from the existing assumption that the master lock
  cannot be acquired while a non-portage process is waiting for it; some kind of
  mode needs to be introduced that will allow exactly that to happen.

o Even though they are not allowed in the CYGDLL_PROTECT variable, it would be nice
  if cygdll-update was able to handle filenames with spaces in them (as of now this
  will have undefined -- but probably very bad -- results).

o If cygdll_protected files are in "removed-in-limbo" state (that is, the file
  is present in cygdll database with the null md5 and has not been physically
  removed), then if a package is merged that wants to create this file, and
  collision-protect is active, then the merge will fail as there is no exception
  made in the collision-protect code against it.  Also, if protect-if-owned is
  active, then the long database search that happens for collisions will run
  occur (although, presumably, the merge will succeed in this case).

  Both of these cases require an exception.  Instead of normal collision behavior,
  the merge should instantly succeed, the file should be installed as the
  currently non-existent _cygdll_protect_foo.dll or whatever, and the new md5
  of the merged file should replace the null md5 which is currently in the
  cygdll database.

o Something needs to be done about rebasing and portage -- we should take a look
  at how portage is handling prelink; maybe can be used as a starting point
  ATM, bad things happen: i.e.: portage shows "!md5" status when unmerging and
  leaves cruft behind.  The whole rebasing approach we have now is also pretty
  poorly written.  In fact all of profile.bashrc is pretty awful.  Could look into
  how rebase is implemented and figure out whether it's worth writing our own
  portage-aware rebase tool -- if we wanted to get really fancy it could auto-update
  saved package files as well as portage .... that could get pretty expensive however!
