o The profile should be reparented at some point so that the
  paths are compatible with a default layman installation

o It turns out that the CHOST setting I have used is an historical
  relic that makes no sense.  I don't know why I didn't figure this
  out sooner; anyhow, instead of 

    CHOST="i686-pc-cygwin1.7"

  we can just have

    CHOST="i686-pc-cygwin"

  and all the various work-arounds in this overlay pertaining to "1.7"
  -- mostly various patches changing bash case statements from, i.e.:

    - *-foo*|*-bar*|*-cygwin|*-baz*)
    + *-foo*|*-bar*|*-cygwin*|*-baz*)

  -- can be abandoned.  yay!  Unfortunately, doing so is going to pretty
  much fsck up my half-completed bootstrap process and I'm too lazy/entrenched
  to comfortably do so just yet.  So for now I guess I am stuck with it.  boo!

o Somehow we want to get rid of ultra-prefixify, it is a horrible abomination.
  One approach would be to build our own cygwin DLL and launcher utility
  (to ensure that no other cygwin DLL gets pulled in).  Armed with
  a cygwin1.dll ebuild (+ whatever else is in cygwin base package),
  we could put in some prefixification patches to avoid i.e. /bin/sh and
  redirect to EPREFIX.

o libtool patches for fork/subshell avoidance

o fix libtool-2.4.2.ebuild to be merely horrible instead of satanically,
  rediculously, unspeakably gross.

o As of now, they are ignored, completely, even if you name them explicitly
  in CYGDLL_PROTECT.  I'm pretty sure that rebase errors could be caused this
  way, if not by .dlls, then almost certainly by symlinks to .exe's.

  I think the following heuristic should be followed when merging them:
  if the file to be merged is a symlink, and the target of that symlink
  (followed recursively in the case of symlinks-to-symlinks, with some
  sort of circular-link detection scheme to prevent disaster) is a
  regular file, and that regular file is considered to be cygdll_protected,
  and the symlink being merged is not identical to a symlink already
  existing in the filesystem (in other words, it's going to be
  created, removed or changed when the merge completes), then put the new
  symlink (or symlink removal) into cygdll protection limbo just as we would
  a regular file being merged.

  What about explicitly CYGDLL_PROTECTED symlinks?  I guess we would need to
  protect those too, and when we recursively followed a link, we would need to
  test each link in the chain for explicit protection.  This is a bit tricky
  since we don't really distinguish between cygdll protections arising from
  heuristics and explicit protections at runtime; but we could just test them
  against the existing list and that would do the trick.

o manpage entries about the items we added to EPREFIX/var/lib/portage

o Clearly absolute paths are not the (full) answer for cygdll-protect.  Either
  implement a kludge like "dll's get their paths stripped for testing
  is_cygdll_protected" or something more generally useful like regular
  expression matching (substututions?) I still wasn't convinced we need this
  until I realized what happens when you move a dll around from version a->b
  of an ebuild -- it's back to the same old BS rebase issues again; there's no
  reason to let continue after building all this infrastructure to prevent it.

o It is desirable for as many portage components as possible to register themselves
  with the master lock, including ebuild.sh and really anything we can figure out
  will be running under the care of portage.  However, to do this correctly we are
  going to need to back down from the existing assumption that the master lock
  cannot be acquired while a non-portage process is waiting for it; some kind of
  mode needs to be introduced that will allow exactly that to happen.

o Even though they are not allowed in the CYGDLL_PROTECT variable, it would be nice
  if cygdll-update was able to handle filenames with spaces in them (as of now this
  will have undefined -- but probably very bad -- results).

o If cygdll_protected files are in "removed-in-limbo" state (that is, the file
  is present in cygdll database with the null md5 and has not been physically
  removed), then if a package is merged that wants to create this file, and
  collision-protect is active, then the merge will fail as there is no exception
  made in the collision-protect code against it.  Also, if protect-if-owned is
  active, then the long database search that happens for collisions will run
  occur (although, presumably, the merge will succeed in this case).

  Both of these cases require an exception.  Instead of normal collision behavior,
  the merge should instantly succeed, the file should be installed as the
  currently non-existent _cygdll_protect_foo.dll or whatever, and the new md5
  of the merged file should replace the null md5 which is currently in the
  cygdll database.

o Something needs to be done about rebasing and portage -- we should take a look
  at how portage is handling prelink; maybe can be used as a starting point
  ATM, bad things happen: i.e.: portage shows "!md5" status when unmerging and
  leaves cruft behind.  The whole rebasing approach we have now is also pretty
  poorly written.  In fact all of profile.bashrc is pretty awful.  Could look into
  how rebase is implemented and figure out whether it's worth writing our own
  portage-aware rebase tool -- if we wanted to get really fancy it could auto-update
  saved package files as well as portage .... that could get pretty expensive however!

o There is a conflict between cygwin and the latest parallel processing commits in
  portage.  Currently, we are reverting those commits but the underlying problem
  needs to be solved -- it's very probably an upstream problem of some kind.

 o Cygdll protection for gcc-config-created dll's.  Although these
   are not portage-managed files, cygdll-protect actually doesn't
   require them to so be and this is a perfect example of
   something we probably ought to be protecting (since they
   get used ubiquitously and can potentially cause huge
   system-wide rebasing issues).

 o Tracking of gcc-config .dll's.  This feature is also lacking
   upstream so I'm reluctant to create a cygwin-specific
   implementation.  But given the ability of cygdll-protect
   to gracefully permit the user to clean up abandoned
   .dlls left by old gcc's, I'm tempted.  Maybe something
   to try later -- ideally this could be implemented  in
   a non-cygwin-specific, non-prefix-specific manner so as
   to allow the general stuff to find its way upstream, and
   then the cygwin/prefix-specific parts could be tacked on,
   however, upstream's implementation of the sharedlib-copying
   is so much simpler that this might be a challenge.

 o For some reason it necessary for us to include some
   "anti-maintainer-mode" patches that upstream doesn't need.
   We should figure out why and fix it somehow!

o We should offer the option of a cygwin-headers package which is built from
  source -- cygwin.cygport doesn't look too hairy although limiting the build
  to just what's needed for headers might be a challenge.
