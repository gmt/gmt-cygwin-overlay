Write normal C, such that we don't need weird compiler requirements or a
gazillion of patches to get this small piece of code to compile on the
various Prefix platforms.

--- python-wrapper.c
+++ python-wrapper.c
@@ -29,6 +29,11 @@
 const char* find_path(const char* exe)
 {
 	const char* last_slash = strrchr(exe, '/');
+	const char *PATH;
+	char *path;
+	const char *token;
+	struct stat sbuf;
+	char *str;
 	if (last_slash)
 	{
 #ifdef HAVE_STRNDUP
@@ -41,8 +46,7 @@
 		return(ret);
 #endif
 	}
-	const char* PATH = getenv("PATH");
-	if (! PATH)
+	if (!(PATH = getenv("PATH")))
 	{
 		/* If PATH is unset, then it defaults to ":/bin:/usr/bin", per
 		 * execvp(3).
@@ -52,9 +56,8 @@
 		 * too */
 		PATH = ":/Library/Gentoo/bin:/Library/Gentoo/usr/bin:/bin:/usr/bin";
 	}
-	char* path = strdup(PATH);
-	char* state = NULL;
-	const char* token = strtok_r(path, ":", &state);
+	path = strdup(PATH);
+	token = strtok(path, ":");
 	while (token)
 	{
 		/* If an element of PATH is empty ("::"), then it is "." */
@@ -62,13 +65,12 @@
 		{
 			token = ".";
 		}
-		struct stat sbuf;
-		char* str = dir_cat(token, exe);
+		str = dir_cat(token, exe);
 		if (stat(str, &sbuf) == 0 && (S_ISREG(sbuf.st_mode) || S_ISLNK(sbuf.st_mode)))
 		{
 			return token;
 		}
-		token = strtok_r(NULL, ":", &state);
+		token = strtok(NULL, ":");
 	}
 	return NULL;
 }
@@ -146,13 +148,14 @@
 const char* find_latest(const char* exe)
 {
 	const char* path = find_path(exe);
+	struct dirent** namelist;
+	int n;
+	const char *ret = NULL;
 	if (! path || ! *path)
 	{
 		path = EPREFIX "/usr/bin";
 	}
-	struct dirent** namelist;
-	int n = scandir(path, &namelist, filter_python, sort_python);
-	const char* ret = NULL;
+	n = scandir(path, &namelist, filter_python, sort_python);
 	if (n < 0)
 	{
 		return NULL;
@@ -168,21 +171,29 @@
 	return ret;
 }
 
-int main(__attribute__((unused)) int argc, char** argv)
+int main(int argc, char** argv)
 {
 	const char* EPYTHON = getenv("EPYTHON");
+	const char *path;
+
+	(void)argc;  /* silence compiler */
+
 	if (! valid_interpreter(EPYTHON))
 	{
 		FILE* f = fopen(ENVD_CONFIG, "r");
 		if (f)
 		{
 			struct stat st;
+			size_t size;
+			size_t len;
+			char *cont;
 			fstat(fileno(f), &st);
-			size_t size = st.st_size;
-			char* cont = malloc(size + 1);
+			size = st.st_size;
+			cont = malloc(size + 1);
+			/* FAIL: need to check cont */
 			cont = fgets(cont, size + 1, f);
 			fclose(f);
-			size_t len = strlen(cont);
+			len = strlen(cont);
 			if (len && cont[len - 1] == '\n')
 				cont[len - 1] = 0;
 			EPYTHON = cont;
@@ -201,8 +212,7 @@
 		return EXIT_ERROR;
 	}
 
-	const char* path = find_path(argv[0]);
-	if (path)
+	if (path = find_path(argv[0]))
 	{
 		argv[0] = dir_cat(path, EPYTHON);
 		execv(argv[0], argv);
