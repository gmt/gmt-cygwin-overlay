diff --git a/lib/Module/Build.pm b/lib/Module/Build.pm
index 356fd42..5d2d6b1 100644
--- a/lib/Module/Build.pm
+++ b/lib/Module/Build.pm
@@ -15,7 +15,7 @@ use Module::Build::Base;
 
 use vars qw($VERSION @ISA);
 @ISA = qw(Module::Build::Base);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 
 # Okay, this is the brute-force method of finding out what kind of
@@ -25,6 +25,7 @@ $VERSION = eval $VERSION;
 my %OSTYPES = qw(
 		 aix       Unix
 		 bsdos     Unix
+		 beos      Unix
 		 dgux      Unix
 		 dragonfly Unix
 		 dynixptx  Unix
@@ -472,6 +473,14 @@ add your own stuff to it:
 See the L<distcheck> and L<skipcheck> actions if you want to find out
 what the C<manifest> action would do, without actually doing anything.
 
+=item manifest_skip
+
+[version 0.3608]
+
+This is an action intended for use by module authors, not people
+installing modules.  It will generate a boilerplate MANIFEST.SKIP file
+if one does not already exist.
+
 =item manpages
 
 [version 0.28]
@@ -733,7 +742,8 @@ Suppress informative messages on output.
 
 =item verbose
 
-Display extra information about the Build on output.
+Display extra information about the Build on output.  C<verbose> will
+turn off C<quiet>
 
 =item cpan_client
 
diff --git a/lib/Module/Build/API.pod b/lib/Module/Build/API.pod
index 146d28e..1f833ca 100644
--- a/lib/Module/Build/API.pod
+++ b/lib/Module/Build/API.pod
@@ -181,6 +181,11 @@ files in the directory will be compiled to object files.  The
 directory will be added to the search path during the compilation and
 linking phases of any C or XS files.
 
+[version 0.3604]
+
+A list of directories can be supplied using an anonymous array
+reference of strings.
+
 =item conflicts
 
 [version 0.07]
@@ -1588,11 +1593,24 @@ of F<META.yml>.   E.g.
     return $data;
   }
 
-The only valid argument is C<fatal>, which indicates whether missing required
+Valid arguments include:
+
+=over
+
+=item *
+
+C<fatal> -- indicates whether missing required
 metadata fields should be a fatal error or not.  For META creation, it
 generally should, but for MYMETA creation for end-users, it should not be
 fatal.
 
+=item *
+
+C<auto> -- indicates whether any necessary configure_requires should be
+automatically added.  This is used in META creation.
+
+=back
+
 This method is a wrapper around the old prepare_metadata API now that we
 no longer use YAML::Node to hold metadata.
 
@@ -1836,7 +1854,7 @@ accessor methods for the following properties:
 
 If you would like to add other useful metadata, C<Module::Build>
 supports this with the C<meta_add> and C<meta_merge> arguments to
-L</new>. The authoritative list of supported metadata can be found at
+L</new()>. The authoritative list of supported metadata can be found at
 L<http://module-build.sourceforge.net/META-spec-current.html>, but for
 convenience - here are a few of the more useful ones:
 
diff --git a/lib/Module/Build/Base.pm b/lib/Module/Build/Base.pm
index 5bd8ec7..4654471 100644
--- a/lib/Module/Build/Base.pm
+++ b/lib/Module/Build/Base.pm
@@ -4,7 +4,7 @@ package Module::Build::Base;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 BEGIN { require 5.00503 }
 
@@ -105,7 +105,7 @@ sub resume {
     my $mb_version = $Module::Build::VERSION;
     if ( $mb_version ne $self->{properties}{mb_version} ) {
       $self->log_warn(<<"MISMATCH");
-* WARNING: Configuration was initially created with Module::Build 
+* WARNING: Configuration was initially created with Module::Build
   version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
   If errors occur, you must re-run the Build.PL or Makefile.PL script.
 MISMATCH
@@ -201,15 +201,15 @@ sub _construct {
 
 sub log_info {
   my $self = shift;
-  print @_ unless(ref($self) and $self->quiet);
+  print @_ if ref($self) && ( $self->verbose || ! $self->quiet );
 }
 sub log_verbose {
   my $self = shift;
-  $self->log_info(@_) if(ref($self) and $self->verbose);
+  print @_ if ref($self) && $self->verbose;
 }
 sub log_debug {
   my $self = shift;
-  print @_ if ref $self && $self->debug;
+  print @_ if ref($self) && $self->debug;
 }
 
 sub log_warn {
@@ -926,8 +926,7 @@ __PACKAGE__->add_property(
 );
 
 {
-  my $Is_ActivePerl = eval {require ActivePerl::DocTools};
-  __PACKAGE__->add_property(html_css => $Is_ActivePerl ? 'Active.css' : '');
+  __PACKAGE__->add_property(html_css => '');
 }
 
 {
@@ -1182,6 +1181,26 @@ sub find_module_by_name { # Method provided for backwards compatibility
   return Module::Build::ModuleInfo->find_module_by_name(@_[1,2]);
 }
 
+{
+  # $unlink_list_for_pid{$$} = [ ... ]
+  my %unlink_list_for_pid;
+
+  sub _unlink_on_exit {
+    my $self = shift;
+    for my $f ( @_ ) {
+      push @{$unlink_list_for_pid{$$}}, $f if -f $f;
+    }
+    return 1;
+  }
+
+  END {
+    for my $f ( map glob($_), @{ $unlink_list_for_pid{$$} || [] } ) {
+      next unless -e $f;
+      File::Path::rmtree($f, 0, 0);
+    }
+  }
+}
+
 sub add_to_cleanup {
   my $self = shift;
   my %files = map {$self->localize_file_path($_), 1} @_;
@@ -1389,8 +1408,8 @@ sub _feature_deps_msg {
     return $log_text;
 }
 
-# Automatically detect and add prerequisites based on configuration
-sub auto_require {
+# Automatically detect configure_requires prereqs
+sub auto_config_requires {
   my ($self) = @_;
   my $p = $self->{properties};
 
@@ -1401,6 +1420,10 @@ sub auto_require {
     && ! exists $p->{configure_requires}{'Module::Build'}
   ) {
     (my $ver = $VERSION) =~ s/^(\d+\.\d\d).*$/$1/; # last major release only
+    $self->log_warn(<<EOM);
+Module::Build was not found in configure_requires! Adding it now
+automatically as: configure_requires => { 'Module::Build' => $ver }
+EOM
     $self->_add_prereq('configure_requires', 'Module::Build', $ver);
   }
 
@@ -1415,6 +1438,14 @@ sub auto_require {
     }
   }
 
+  return;
+}
+
+# Automatically detect and add prerequisites based on configuration
+sub auto_require {
+  my ($self) = @_;
+  my $p = $self->{properties};
+
   # If needs_compiler is not explictly set, automatically set it
   # If set, we need ExtUtils::CBuilder (and a compiler)
   my $xs_files = $self->find_xs_files;
@@ -1572,7 +1603,7 @@ sub check_installed_status {
       return \%status;
     }
 
-    $status{have} = $pm_info->version();
+    $status{have} = eval { $pm_info->version() };
     if ($spec and !defined($status{have})) {
       @status{ qw(have message) } = (undef, "Couldn't find a \$VERSION in prerequisite $modname");
       return \%status;
@@ -1686,9 +1717,6 @@ sub print_build_script {
 
   my %q = map {$_, $self->$_()} qw(config_dir base_dir);
 
-  my $case_tolerant = 0+(File::Spec->can('case_tolerant')
-			 && File::Spec->case_tolerant);
-  $q{base_dir} = uc $q{base_dir} if $case_tolerant;
   $q{base_dir} = Win32::GetShortPathName($q{base_dir}) if $self->is_windowsish;
 
   $q{magic_numfile} = $self->config_file('magicnum');
@@ -1783,8 +1811,8 @@ sub create_mymeta {
   # if we read META OK, just update it
   if ( defined $mymeta ) {
     my $prereqs = $self->_normalize_prereqs;
-    for my $t ( keys %$prereqs ) {
-        $mymeta->{$t} = $prereqs->{$t};
+    for my $t ( 'configure_requires', @{$self->prereq_action_types} ) {
+        $mymeta->{$t} = $prereqs->{$t} if $prereqs->{$t};
     }
   }
   # but generate from scratch, ignoring errors if META doesn't exist
@@ -1958,7 +1986,6 @@ sub _translate_option {
     create_readme
     extra_compiler_flags
     extra_linker_flags
-    html_css
     install_base
     install_path
     meta_add
@@ -2667,7 +2694,7 @@ sub ACTION_testcover {
   # testcover was run.  If so, start over.
   if (-e 'cover_db') {
     my $pm_files = $self->rscan_dir
-        (File::Spec->catdir($self->blib, 'lib'), file_qr('\.pm$') );
+        (File::Spec->catdir($self->blib, 'lib'), $self->file_qr('\.pm$') );
     my $cover_files = $self->rscan_dir('cover_db', sub {-f $_ and not /\.html$/});
 
     $self->do_system(qw(cover -delete))
@@ -2728,11 +2755,19 @@ sub process_support_files {
   my $p = $self->{properties};
   return unless $p->{c_source};
 
-  push @{$p->{include_dirs}}, $p->{c_source};
+  my $files;
+  if (ref($p->{c_source}) eq "ARRAY") {
+      push @{$p->{include_dirs}}, @{$p->{c_source}};
+      for my $path (@{$p->{c_source}}) {
+          push @$files, @{ $self->rscan_dir($path, $self->file_qr('\.c(c|p|pp|xx|\+\+)?$')) };
+      }
+  } else {
+      push @{$p->{include_dirs}}, $p->{c_source};
+      $files = $self->rscan_dir($p->{c_source}, $self->file_qr('\.c(c|p|pp|xx|\+\+)?$'));
+  }
 
-  my $files = $self->rscan_dir($p->{c_source}, file_qr('\.c(c|p|pp|xx|\+\+)?$'));
   foreach my $file (@$files) {
-    push @{$p->{objects}}, $self->compile_c($file);
+      push @{$p->{objects}}, $self->compile_c($file);
   }
 }
 
@@ -2852,8 +2887,10 @@ sub find_PL_files {
   }
 
   return unless -d 'lib';
-  return { map {$_, [/^(.*)\.PL$/i ]} @{ $self->rscan_dir('lib',
-                                                          file_qr('\.PL$')) } };
+  return { 
+    map {$_, [/^(.*)\.PL$/i ]} 
+    @{ $self->rscan_dir('lib', $self->file_qr('\.PL$')) } 
+  };
 }
 
 sub find_pm_files  { shift->_find_file_by_type('pm',  'lib') }
@@ -2906,7 +2943,7 @@ sub _find_file_by_type {
   return { map {$_, $_}
 	   map $self->localize_file_path($_),
 	   grep !/\.\#/,
-	   @{ $self->rscan_dir($dir, file_qr("\\.$type\$")) } };
+	   @{ $self->rscan_dir($dir, $self->file_qr("\\.$type\$")) } };
 }
 
 sub localize_file_path {
@@ -2934,7 +2971,7 @@ sub fix_shebang_line { # Adapted from fixin() in ExtUtils::MM_Unix 1.35
     next unless $cmd =~ /perl/i;
     my $interpreter = $self->{properties}{perl};
 
-    $self->log_verbose("Changing sharpbang in $file to $interpreter");
+    $self->log_verbose("Changing sharpbang in $file to $interpreter\n");
     my $shb = '';
     $shb .= $c->get('sharpbang')."$interpreter $arg\n" if $does_shbang;
 
@@ -2979,7 +3016,7 @@ sub ACTION_testpod {
   my @files = sort keys %{$self->_find_pods($self->libdoc_dirs)},
                    keys %{$self->_find_pods
                              ($self->bindoc_dirs,
-                              exclude => [ file_qr('\.bat$') ])}
+                              exclude => [ $self->file_qr('\.bat$') ])}
     or die "Couldn't find any POD files to test\n";
 
   { package # hide from PAUSE
@@ -3033,6 +3070,24 @@ sub _is_default_installable {
 	 ) ? 1 : 0;
 }
 
+sub _is_ActivePerl {
+#  return 0;
+  my $self = shift;
+  unless (exists($self->{_is_ActivePerl})) {
+    $self->{_is_ActivePerl} = (eval { require ActivePerl::DocTools; } || 0);
+  }
+  return $self->{_is_ActivePerl};
+}
+
+sub _is_ActivePPM {
+#  return 0;
+  my $self = shift;
+  unless (exists($self->{_is_ActivePPM})) {
+    $self->{_is_ActivePPM} = (eval { require ActivePerl::PPM; } || 0);
+  }
+  return $self->{_is_ActivePPM};
+}
+
 sub ACTION_manpages {
   my $self = shift;
 
@@ -3041,27 +3096,21 @@ sub ACTION_manpages {
   $self->depends_on('code');
 
   foreach my $type ( qw(bin lib) ) {
+    next unless ( $self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));
     my $files = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
-                                   exclude => [ file_qr('\.bat$') ] );
+                                   exclude => [ $self->file_qr('\.bat$') ] );
     next unless %$files;
 
     my $sub = $self->can("manify_${type}_pods");
-    next unless defined( $sub );
-
-    if ( $self->invoked_action eq 'manpages' ) {
-      $self->$sub();
-    } elsif ( $self->_is_default_installable("${type}doc") ) {
-      $self->$sub();
-    }
+    $self->$sub() if defined( $sub );
   }
-
 }
 
 sub manify_bin_pods {
   my $self    = shift;
 
   my $files   = $self->_find_pods( $self->{properties}{bindoc_dirs},
-                                   exclude => [ file_qr('\.bat$') ] );
+                                   exclude => [ $self->file_qr('\.bat$') ] );
   return unless keys %$files;
 
   my $mandir = File::Spec->catdir( $self->blib, 'bindoc' );
@@ -3145,21 +3194,11 @@ sub ACTION_html {
   $self->depends_on('code');
 
   foreach my $type ( qw(bin lib) ) {
-    my $files = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
-				   exclude =>
-                                        [ file_qr('\.(?:bat|com|html)$') ] );
-    next unless %$files;
-
-    if ( $self->invoked_action eq 'html' ) {
-      $self->htmlify_pods( $type );
-    } elsif ( $self->_is_default_installable("${type}html") ) {
-      $self->htmlify_pods( $type );
-    }
+    next unless ( $self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));
+    $self->htmlify_pods( $type );
   }
-
 }
 
-
 # 1) If it's an ActiveState perl install, we need to run
 #    ActivePerl::DocTools->UpdateTOC;
 # 2) Links to other modules are not being generated
@@ -3168,13 +3207,10 @@ sub htmlify_pods {
   my $type = shift;
   my $htmldir = shift || File::Spec->catdir($self->blib, "${type}html");
 
-  require Module::Build::PodParser;
-  require Pod::Html;
-
   $self->add_to_cleanup('pod2htm*');
 
   my $pods = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
-                                exclude => [ file_qr('\.(?:bat|com|html)$') ] );
+                                exclude => [ $self->file_qr('\.(?:bat|com|html)$') ] );
   return unless %$pods;  # nothing to do
 
   unless ( -d $htmldir ) {
@@ -3184,21 +3220,50 @@ sub htmlify_pods {
 
   my @rootdirs = ($type eq 'bin') ? qw(bin) :
       $self->installdirs eq 'core' ? qw(lib) : qw(site lib);
+  my $podroot = $self->original_prefix('core');
+
+  my $htmlroot = $self->install_sets('core')->{libhtml};
+  my @podpath = (map { File::Spec->abs2rel($_ ,$podroot) } grep { -d  }
+    ( $self->install_sets('core', 'lib'), # lib
+      $self->install_sets('core', 'bin'), # bin
+      $self->install_sets('site', 'lib'), # site/lib
+    ),File::Spec->rel2abs($self->blib)
+  );
+
+  my $podpath = join(":", map { tr,:\\,|/,; $_ } @podpath);
+
+  my $blibdir = join('/', File::Spec->splitdir(
+    (File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),''
+  );
 
-  my $podpath = join ':',
-                map  $_->[1],
-                grep -e $_->[0],
-                map  [File::Spec->catdir($self->blib, $_), $_],
-                qw( script lib );
+  my ($with_ActiveState, $htmltool);
 
+  if ( $with_ActiveState = $self->_is_ActivePerl
+    && eval { require ActivePerl::DocTools::Pod; 1 }
+  ) {
+    $htmltool = "ActiveState::DocTools::Pod " .
+      ActiveState::DocTools::Pod->VERSION;
+  }
+  else {
+      require Module::Build::PodParser;
+      require Pod::Html;
+    $htmltool = "Pod::Html " .  Pod::Html->VERSION;
+  }
+  $self->log_verbose("Converting Pod to HTML with $htmltool\n");
+
+  my $errors = 0;
+
+  POD:
   foreach my $pod ( keys %$pods ) {
 
     my ($name, $path) = File::Basename::fileparse($pods->{$pod},
-                                                 file_qr('\.(?:pm|plx?|pod)$'));
+      $self->file_qr('\.(?:pm|plx?|pod)$')
+    );
     my @dirs = File::Spec->splitdir( File::Spec->canonpath( $path ) );
     pop( @dirs ) if scalar(@dirs) && $dirs[-1] eq File::Spec->curdir;
 
-    my $fulldir = File::Spec->catfile($htmldir, @rootdirs, @dirs);
+    my $fulldir = File::Spec->catdir($htmldir, @rootdirs, @dirs);
+    my $tmpfile = File::Spec->catfile($fulldir, "${name}.tmp");
     my $outfile = File::Spec->catfile($fulldir, "${name}.html");
     my $infile  = File::Spec->abs2rel($pod);
 
@@ -3209,38 +3274,78 @@ sub htmlify_pods {
         or die "Couldn't mkdir $fulldir: $!";
     }
 
-    my $path2root = join( '/', ('..') x (@rootdirs+@dirs) );
-    my $htmlroot = join( '/',
-			 ($path2root,
-			  $self->installdirs eq 'core' ? () : qw(site) ) );
-
-    my $fh = IO::File->new($infile) or die "Can't read $infile: $!";
-    my $abstract = Module::Build::PodParser->new(fh => $fh)->get_abstract();
-
-    my $title = join( '::', (@dirs, $name) );
-    $title .= " - $abstract" if $abstract;
-
-    my @opts = (
-                '--flush',
-                "--title=$title",
-                "--podpath=$podpath",
-                "--infile=$infile",
-                "--outfile=$outfile",
-                '--podroot=' . $self->blib,
-                "--htmlroot=$htmlroot",
-               );
-
-    if ( eval{Pod::Html->VERSION(1.03)} ) {
-      push( @opts, ('--header', '--backlink=Back to Top') );
-      push( @opts, "--css=$path2root/" . $self->html_css) if $self->html_css;
+    $self->log_verbose("HTMLifying $infile -> $outfile\n");
+    if ( $with_ActiveState ) {
+      my $depth = @rootdirs + @dirs;
+      my %opts = ( infile => $infile,
+        outfile => $tmpfile,
+        podpath => $podpath,
+        podroot => $podroot,
+        index => 1,
+        depth => $depth,
+      );
+      eval {
+        ActivePerl::DocTools::Pod::pod2html(%opts);
+        1;
+      } or $self->log_warn("[$htmltool] pod2html (" .
+        join(", ", map { "q{$_} => q{$opts{$_}}" } (keys %opts)) . ") failed: $@");
+    } else {
+      my $path2root = join( '/', ('..') x (@rootdirs+@dirs) );
+      my $fh = IO::File->new($infile) or die "Can't read $infile: $!";
+      my $abstract = Module::Build::PodParser->new(fh => $fh)->get_abstract();
+
+      my $title = join( '::', (@dirs, $name) );
+      $title .= " - $abstract" if $abstract;
+
+      my @opts = (
+        '--flush',
+        "--title=$title",
+        "--podpath=$podpath",
+        "--infile=$infile",
+        "--outfile=$tmpfile",
+        "--podroot=$podroot",
+        "--htmlroot=$path2root",
+      );
+
+      if ( eval{Pod::Html->VERSION(1.03)} ) {
+        push( @opts, ('--header', '--backlink=Back to Top') );
+      }
+
+      $self->log_verbose("P::H::pod2html @opts\n");
+      eval { Pod::Html::pod2html(@opts); 1 }
+        or $self->log_warn("[$htmltool] pod2html( " .
+        join(", ", map { "q{$_}" } @opts) . ") failed: $@");
+    }
+    # We now have to cleanup the resulting html file
+    if ( ! -r $tmpfile ) {
+      $errors++;
+      next POD;
     }
+    my $fh = IO::File->new($tmpfile) or die "Can't read $tmpfile: $!";
+    my $html = join('',<$fh>);
+    $fh->close;
+    if (!$self->_is_ActivePerl) {
+      # These fixups are already done by AP::DT:P:pod2html
+      # The output from pod2html is NOT XHTML!
+      # IE6+ will display content that is not valid for DOCTYPE
+      $html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;
+      $html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;
+
+      # IE6+ will not display local HTML files with strict
+      # security without this comment
+      $html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i;
+    }
+    # Fixup links that point to our temp blib
+    $html =~ s/\Q$blibdir\E//g;
 
-    $self->log_verbose("HTMLifying $infile -> $outfile\n");
-    $self->log_verbose("pod2html @opts\n");
-    eval { Pod::Html::pod2html(@opts); 1 }
-      or $self->log_warn("pod2html @opts failed: $@");
+    $fh = IO::File->new(">$outfile") or die "Can't write $outfile: $!";
+    print $fh $html;
+    $fh->close;
+    unlink($tmpfile);
   }
 
+  return ! $errors;
+
 }
 
 # Adapted from ExtUtils::MM_Unix
@@ -3285,7 +3390,7 @@ sub ACTION_diff {
   delete $installmap->{read};
   delete $installmap->{write};
 
-  my $text_suffix = file_qr('\.(pm|pod)$');
+  my $text_suffix = $self->file_qr('\.(pm|pod)$');
 
   while (my $localdir = each %$installmap) {
     my @localparts = File::Spec->splitdir($localdir);
@@ -3324,6 +3429,27 @@ sub ACTION_install {
   require ExtUtils::Install;
   $self->depends_on('build');
   ExtUtils::Install::install($self->install_map, $self->verbose, 0, $self->{args}{uninst}||0);
+  if ($self->_is_ActivePerl && $self->{_completed_actions}{html}) {
+    $self->log_info("Building ActivePerl Table of Contents\n");
+    eval { ActivePerl::DocTools::WriteTOC(verbose => $self->verbose ? 1 : 0); 1; }
+      or $self->log_warn("AP::DT:: WriteTOC() failed: $@");
+  }
+  if ($self->_is_ActivePPM) {
+    # We touch 'lib/perllocal.pod'. There is an existing logic in subroutine _init_db()
+    # of 'ActivePerl/PPM/InstallArea.pm' that says that if 'lib/perllocal.pod' has a 'date-last-touched'
+    # greater than that of the PPM SQLite databases ('etc/ppm-perl-area.db' and/or
+    # 'site/etc/ppm-site-area.db') then the PPM SQLite databases are rebuilt from scratch.
+
+    # in the following line, 'perllocal.pod' this is *always* 'lib/perllocal.pod', never 'site/lib/perllocal.pod'
+    my $F_perllocal = File::Spec->catfile($self->install_sets('core', 'lib'), 'perllocal.pod');
+    my $dt_stamp = time;
+
+    $self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");
+
+    open PERLLOCAL, ">>$F_perllocal";
+    close PERLLOCAL;
+    utime($dt_stamp, $dt_stamp, $F_perllocal);
+  }
 }
 
 sub ACTION_fakeinstall {
@@ -3476,7 +3602,6 @@ sub ACTION_ppmdist {
   }
 
   foreach my $type ( qw(bin lib) ) {
-    local $self->{properties}{html_css} = 'Active.css';
     $self->htmlify_pods( $type, File::Spec->catdir($ppm, 'blib', 'html') );
   }
 
@@ -3513,7 +3638,8 @@ sub ACTION_pardist {
 sub ACTION_dist {
   my ($self) = @_;
 
-  $self->depends_on('distdir');
+  # MUST dispatch() and not depends_ok() so we generate a clean distdir
+  $self->dispatch('distdir');
 
   my $dist_dir = $self->dist_dir;
 
@@ -3645,7 +3771,11 @@ sub do_create_makefile_pl {
   my $self = shift;
   require Module::Build::Compat;
   $self->log_info("Creating Makefile.PL\n");
-  Module::Build::Compat->create_makefile_pl($self->create_makefile_pl, $self, @_);
+  eval { Module::Build::Compat->create_makefile_pl($self->create_makefile_pl, $self, @_) };
+  if ( $@ ) {
+    1 while unlink 'Makefile.PL';
+    die "$@\n";
+  }
   $self->_add_to_manifest('MANIFEST', 'Makefile.PL');
 }
 
@@ -3662,7 +3792,10 @@ sub do_create_license {
     or die "No license specified";
 
   my $key = $self->valid_licenses->{$l}
-    or die "'$l' isn't a license key we know about";
+    or die "'$l' isn't a recognized license\n",
+           "licenses we know about:\n",
+           map { "\t$_\n" } sort keys %{ $self->valid_licenses };
+
   my $class = "Software::License::$key";
 
   eval "use $class; 1"
@@ -3770,9 +3903,6 @@ sub ACTION_distdir {
 
   $self->depends_on('distmeta');
 
-  # Must not include MYMETA
-  $self->_check_mymeta_skip('MANIFEST.SKIP');
-
   my $dist_files = $self->_read_manifest('MANIFEST')
     or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";
   delete $dist_files->{SIGNATURE};  # Don't copy, create a fresh one
@@ -3788,6 +3918,7 @@ sub ACTION_distdir {
   $self->add_to_cleanup($dist_dir);
 
   foreach my $file (keys %$dist_files) {
+    next if $file =~ m{^MYMETA\.}; # Double check that we skip MYMETA.*
     my $new = $self->copy_if_modified(from => $file, to_dir => $dist_dir, verbose => 0);
   }
 
@@ -3873,12 +4004,33 @@ Reads $file and returns the $content.
 sub _slurp {
     my $self = shift;
     my $file = shift;
-    open my $fh, "<", $file or croak "Can't open $file: $!";
+    my $mode = shift || "";
+    open my $fh, "<$mode", $file or croak "Can't open $file for reading: $!";
     local $/;
     return <$fh>;
 }
 
+sub _spew {
+    my $self = shift;
+    my $file = shift;
+    my $content = shift || "";
+    my $mode = shift || "";
+    open my $fh, ">$mode", $file or croak "Can't open $file for writing: $!";
+    print {$fh} $content;
+    close $fh;
+}
 
+sub _case_tolerant {
+  my $self = shift;
+  if ( ref $self ) {
+    $self->{_case_tolerant} = File::Spec->case_tolerant
+      unless defined($self->{_case_tolerant});
+    return $self->{_case_tolerant};
+  }
+  else {
+    return File::Spec->case_tolerant;
+  }
+}
 
 sub _append_maniskip {
   my $self = shift;
@@ -3933,7 +4085,7 @@ sub _check_manifest_skip {
   if ( ! -e $maniskip ) {
     $self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");
     $self->_write_default_maniskip($maniskip);
-    $self->add_to_cleanup($maniskip);
+    $self->_unlink_on_exit($maniskip);
   }
   else {
     # MYMETA must not be added to MANIFEST, so always confirm the skip
@@ -3953,9 +4105,21 @@ sub ACTION_manifest {
   ExtUtils::Manifest::mkmanifest();
 }
 
+sub ACTION_manifest_skip {
+  my ($self) = @_;
+
+  if ( -e 'MANIFEST.SKIP' ) {
+    $self->log_warn("MANIFEST.SKIP already exists.\n");
+    return 0;
+  }
+  $self->log_info("Creating a new MANIFEST.SKIP file\n");
+  return $self->_write_default_maniskip;
+  return -e 'MANIFEST.SKIP'
+}
+
 # Case insensitive regex for files
 sub file_qr {
-    return File::Spec->case_tolerant ? qr($_[0])i : qr($_[0]);
+    return shift->{_case_tolerant} ? qr($_[0])i : qr($_[0]);
 }
 
 sub dist_dir {
@@ -4058,13 +4222,13 @@ sub script_files {
   }
 
   my %pl_files = map {
-    File::Spec->canonpath( File::Spec->case_tolerant ? uc $_ : $_ ) => 1
+    File::Spec->canonpath( $_ ) => 1
   } keys %{ $self->PL_files || {} };
 
   my @bin_files = $self->_files_in('bin');
 
   my %bin_map = map {
-    $_ => File::Spec->canonpath( File::Spec->case_tolerant ? uc $_ : $_ )
+    $_ => File::Spec->canonpath( $_ )
   } @bin_files;
 
   return $_ = { map {$_ => 1} grep !$pl_files{$bin_map{$_}}, @bin_files };
@@ -4136,7 +4300,6 @@ sub _hash_merge {
 
 sub ACTION_distmeta {
   my ($self) = @_;
-
   $self->do_create_makefile_pl if $self->create_makefile_pl;
   $self->do_create_readme if $self->create_readme;
   $self->do_create_license if $self->create_license;
@@ -4170,7 +4333,11 @@ sub do_create_metafile {
     push @INC, File::Spec->catdir($self->blib, 'lib');
   }
 
-  if ($self->write_metafile($self->metafile,$self->get_metadata(fatal=>1))){
+  if (
+    $self->write_metafile(
+      $self->metafile,$self->get_metadata(fatal=>1, auto => 1)
+    )
+  ){
     $self->{wrote_metadata} = 1;
     $self->_add_to_manifest('MANIFEST', $metafile);
   }
@@ -4178,6 +4345,7 @@ sub do_create_metafile {
   return 1;
 }
 
+# We handle slurping from the metafile to ensure proper utf8 if possible
 sub read_metafile {
   my $self = shift;
   my ($metafile) = @_;
@@ -4187,12 +4355,15 @@ sub read_metafile {
             ? 'YAML::Tiny' : 'Module::Build::YAML' ;
 
   eval "require $class; 1" or die $@;
-  my $meta = $class->read($metafile)
-    or $self->log_warn( "Error reading '$metafile': " . $class->errstr . "\n");
+
+  my $string = $self->_slurp($metafile, $] < 5.8 ? "" : ":utf8");
+  my $meta = $class->read_string($string)
+    or $self->log_warn( "Error parsing '$metafile': " . $class->errstr . "\n");
 
   return $meta->[0] || {};
 }
 
+# We handle spewing to the metafile to ensure proper utf8 if possible
 sub write_metafile {
   my $self = shift;
   my ($metafile, $node) = @_;
@@ -4206,9 +4377,8 @@ sub write_metafile {
     require Module::Build::YAML;
     $yaml = Module::Build::YAML->new($node);
   }
-  my $result = $yaml->write($metafile)
-    or $self->log_warn( "Error writing '$metafile': " . $yaml->errstr . "\n");
-  return $result;
+  my $string = $yaml->write_string;
+  return $self->_spew($metafile, $string, $] < 5.8 ? "" : ":utf8")
 }
 
 sub normalize_version {
@@ -4270,6 +4440,8 @@ sub prepare_metadata {
   my $fatal = $args->{fatal} || 0;
   my $p = $self->{properties};
 
+  $self->auto_config_requires if $args->{auto};
+
   # A little helper sub
   my $add_node = sub {
     my ($name, $val) = @_;
@@ -4385,6 +4557,8 @@ sub find_dist_packages {
   return $self->find_packages_in_files(\@pm_files, \%dist_files);
 }
 
+# XXX Do not document this function; mst wrote it and now says the API is
+# stupid and needs to be fixed and it shouldn't become a public API until then
 sub find_packages_in_files {
   my ($self, $file_list, $filename_map) = @_;
 
@@ -4791,6 +4965,13 @@ sub install_map {
     my $localdir = File::Spec->catdir( $blib, $type );
     next unless -e $localdir;
 
+    # the line "...next if (($type eq 'bindoc'..." was one of many changes introduced for
+    # improving HTML generation on ActivePerl, see https://rt.cpan.org/Public/Bug/Display.html?id=53478
+    # Most changes were ok, but this particular line caused test failures in t/manifypods.t on windows,
+    # therefore it is commented out.
+
+    # ********* next if (($type eq 'bindoc' || $type eq 'libdoc') && not $self->is_unixish);
+
     if (my $dest = $self->install_destination($type)) {
       $map{$localdir} = $dest;
     } else {
@@ -5234,7 +5415,7 @@ sub dir_contains {
 
   return 0 if @second_dirs < @first_dirs;
 
-  my $is_same = ( File::Spec->case_tolerant
+  my $is_same = ( $self->_case_tolerant
 		  ? sub {lc(shift()) eq lc(shift())}
 		  : sub {shift() eq shift()} );
 
diff --git a/lib/Module/Build/Compat.pm b/lib/Module/Build/Compat.pm
index 6cd80dd..a8ba940 100644
--- a/lib/Module/Build/Compat.pm
+++ b/lib/Module/Build/Compat.pm
@@ -2,7 +2,7 @@ package Module::Build::Compat;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 
 use File::Basename ();
 use File::Spec;
@@ -10,6 +10,7 @@ use IO::File;
 use Config;
 use Module::Build;
 use Module::Build::ModuleInfo;
+use Module::Build::Version;
 use Data::Dumper;
 
 my %convert_installdirs = (
@@ -64,10 +65,6 @@ my %macro_to_build = %makefile_to_build;
 # "LIB=foo make" is not the same as "perl Makefile.PL LIB=foo"
 delete $macro_to_build{LIB};
 
-sub _simple_prereq {
-  return $_[0] =~ /^[0-9_]+\.?[0-9_]*$/; # crudly, a decimal literal
-}
-
 sub _merge_prereq {
   my ($req, $breq) = @_;
   $req ||= {};
@@ -76,8 +73,19 @@ sub _merge_prereq {
   # validate formats
   for my $p ( $req, $breq ) {
     for my $k (keys %$p) {
-      die "Prereq '$p->{$k}' for '$k' is not supported by Module::Build::Compat\n"
-        unless _simple_prereq($p->{$k});
+      next if $k eq 'perl';
+
+      my $v_obj = eval { Module::Build::Version->new($p->{$k}) };
+      if ( ! defined $v_obj ) {
+          die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n";
+      }
+
+      # It seems like a lot of people trip over "0.1.2" stuff, so we help them here...
+      if ( $v_obj->is_qv ) {
+        my $proper_ver = $v_obj->numify;
+        warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";
+        $p->{$k} = $proper_ver;
+      }
     }
   }
   # merge
@@ -124,7 +132,8 @@ HERE
   # Makefile.PL
   my $requires = $build->requires;
   if ( my $minimum_perl = $requires->{perl} ) {
-    print {$fh} "require $minimum_perl;\n";
+    my $min_ver = Module::Build::Version->new($minimum_perl)->numify;
+    print {$fh} "require $min_ver;\n";
   }
 
   # If a *bundled* custom subclass is being used, make sure we add its
diff --git a/lib/Module/Build/Config.pm b/lib/Module/Build/Config.pm
index 9979600..2a1e989 100644
--- a/lib/Module/Build/Config.pm
+++ b/lib/Module/Build/Config.pm
@@ -2,7 +2,7 @@ package Module::Build::Config;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Config;
 
diff --git a/lib/Module/Build/Cookbook.pm b/lib/Module/Build/Cookbook.pm
index a68dca5..b092093 100644
--- a/lib/Module/Build/Cookbook.pm
+++ b/lib/Module/Build/Cookbook.pm
@@ -1,7 +1,7 @@
 package Module::Build::Cookbook;
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 
 
 =head1 NAME
diff --git a/lib/Module/Build/Dumper.pm b/lib/Module/Build/Dumper.pm
index 2a9bad1..7a8c69a 100644
--- a/lib/Module/Build/Dumper.pm
+++ b/lib/Module/Build/Dumper.pm
@@ -1,7 +1,7 @@
 package Module::Build::Dumper;
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 
 # This is just a split-out of a wrapper function to do Data::Dumper
 # stuff "the right way".  See:
diff --git a/lib/Module/Build/ModuleInfo.pm b/lib/Module/Build/ModuleInfo.pm
index 053ae18..d9df9de 100644
--- a/lib/Module/Build/ModuleInfo.pm
+++ b/lib/Module/Build/ModuleInfo.pm
@@ -8,7 +8,7 @@ package Module::Build::ModuleInfo;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 
 use File::Spec;
@@ -345,11 +345,12 @@ sub _evaluate_version_line {
   }
 
   # Bless it into our own version class
-  eval { $result = Module::Build::Version->new($result) };
-  die "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
+  my $vobj;
+  eval { $vobj = Module::Build::Version->new($result) };
+  warn "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe error was: $@\n"
     if $@;
 
-  return $result;
+  return $vobj;
 }
 }
 
diff --git a/lib/Module/Build/Notes.pm b/lib/Module/Build/Notes.pm
index cf85d4e..f64a200 100644
--- a/lib/Module/Build/Notes.pm
+++ b/lib/Module/Build/Notes.pm
@@ -4,7 +4,7 @@ package Module::Build::Notes;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Data::Dumper;
 use IO::File;
diff --git a/lib/Module/Build/PPMMaker.pm b/lib/Module/Build/PPMMaker.pm
index 977b437..af5724c 100644
--- a/lib/Module/Build/PPMMaker.pm
+++ b/lib/Module/Build/PPMMaker.pm
@@ -5,7 +5,7 @@ use Config;
 use vars qw($VERSION);
 use IO::File;
 
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 
 # This code is mostly borrowed from ExtUtils::MM_Unix 6.10_03, with a
diff --git a/lib/Module/Build/Platform/Amiga.pm b/lib/Module/Build/Platform/Amiga.pm
index 9356325..ea7301d 100644
--- a/lib/Module/Build/Platform/Amiga.pm
+++ b/lib/Module/Build/Platform/Amiga.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::Amiga;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 
diff --git a/lib/Module/Build/Platform/Default.pm b/lib/Module/Build/Platform/Default.pm
index 8d46fc4..aa0ac41 100644
--- a/lib/Module/Build/Platform/Default.pm
+++ b/lib/Module/Build/Platform/Default.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::Default;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 
diff --git a/lib/Module/Build/Platform/EBCDIC.pm b/lib/Module/Build/Platform/EBCDIC.pm
index 140e278..7374b17 100644
--- a/lib/Module/Build/Platform/EBCDIC.pm
+++ b/lib/Module/Build/Platform/EBCDIC.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::EBCDIC;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 
diff --git a/lib/Module/Build/Platform/MPEiX.pm b/lib/Module/Build/Platform/MPEiX.pm
index 66bbdc9..e08ef63 100644
--- a/lib/Module/Build/Platform/MPEiX.pm
+++ b/lib/Module/Build/Platform/MPEiX.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::MPEiX;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 
diff --git a/lib/Module/Build/Platform/MacOS.pm b/lib/Module/Build/Platform/MacOS.pm
index b80781b..f90d1ee 100644
--- a/lib/Module/Build/Platform/MacOS.pm
+++ b/lib/Module/Build/Platform/MacOS.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::MacOS;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 use vars qw(@ISA);
diff --git a/lib/Module/Build/Platform/RiscOS.pm b/lib/Module/Build/Platform/RiscOS.pm
index 95e3151..c040601 100644
--- a/lib/Module/Build/Platform/RiscOS.pm
+++ b/lib/Module/Build/Platform/RiscOS.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::RiscOS;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 
diff --git a/lib/Module/Build/Platform/Unix.pm b/lib/Module/Build/Platform/Unix.pm
index 0be5fc7..86749fa 100644
--- a/lib/Module/Build/Platform/Unix.pm
+++ b/lib/Module/Build/Platform/Unix.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::Unix;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 
diff --git a/lib/Module/Build/Platform/VMS.pm b/lib/Module/Build/Platform/VMS.pm
index f406b7a..97bc969 100644
--- a/lib/Module/Build/Platform/VMS.pm
+++ b/lib/Module/Build/Platform/VMS.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::VMS;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 use Config;
@@ -77,10 +77,29 @@ Prefixify taking into account VMS' filepath syntax.
 =cut
 
 # Translated from ExtUtils::MM_VMS::prefixify()
+
+sub _catprefix {
+    my($self, $rprefix, $default) = @_;
+
+    my($rvol, $rdirs) = File::Spec->splitpath($rprefix);
+    if( $rvol ) {
+        return File::Spec->catpath($rvol,
+                                   File::Spec->catdir($rdirs, $default),
+                                   ''
+                                  )
+    }
+    else {
+        return File::Spec->catdir($rdirs, $default);
+    }
+}
+
+
 sub _prefixify {
     my($self, $path, $sprefix, $type) = @_;
     my $rprefix = $self->prefix;
 
+    return '' unless defined $path;
+
     $self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");
 
     # Translate $(PERLPREFIX) to a real path.
@@ -90,7 +109,7 @@ sub _prefixify {
     $self->log_verbose("  rprefix translated to $rprefix\n".
                        "  sprefix translated to $sprefix\n");
 
-    if( length $path == 0 ) {
+    if( length($path) == 0 ) {
         $self->log_verbose("  no path to prefixify.\n")
     }
     elsif( !File::Spec->file_name_is_absolute($path) ) {
diff --git a/lib/Module/Build/Platform/VOS.pm b/lib/Module/Build/Platform/VOS.pm
index 001a950..bd5371d 100644
--- a/lib/Module/Build/Platform/VOS.pm
+++ b/lib/Module/Build/Platform/VOS.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::VOS;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Base;
 
diff --git a/lib/Module/Build/Platform/Windows.pm b/lib/Module/Build/Platform/Windows.pm
index 1e248a7..c8d3470 100644
--- a/lib/Module/Build/Platform/Windows.pm
+++ b/lib/Module/Build/Platform/Windows.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::Windows;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 
 use Config;
diff --git a/lib/Module/Build/Platform/aix.pm b/lib/Module/Build/Platform/aix.pm
index dab0648..a1bfa77 100644
--- a/lib/Module/Build/Platform/aix.pm
+++ b/lib/Module/Build/Platform/aix.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::aix;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Platform::Unix;
 
diff --git a/lib/Module/Build/Platform/cygwin.pm b/lib/Module/Build/Platform/cygwin.pm
index 37c59ad..611d1fa 100644
--- a/lib/Module/Build/Platform/cygwin.pm
+++ b/lib/Module/Build/Platform/cygwin.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::cygwin;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Platform::Unix;
 
@@ -14,7 +14,7 @@ sub manpage_separator {
 }
 
 # Copied from ExtUtils::MM_Cygwin::maybe_command()
-# If our path begins with F</cygdrive/> then we use C<ExtUtils::MM_Win32>
+# If our path begins with F</cygdrive/> then we use the Windows version
 # to determine if it may be a command.  Otherwise we use the tests
 # from C<ExtUtils::MM_Unix>.
 
@@ -22,8 +22,8 @@ sub _maybe_command {
     my ($self, $file) = @_;
 
     if ($file =~ m{^/cygdrive/}i) {
-        require Module::Build::Platform::Win32;
-        return Module::Build::Platform::Win32->_maybe_command($file);
+        require Module::Build::Platform::Windows;
+        return Module::Build::Platform::Windows->_maybe_command($file);
     }
 
     return $self->SUPER::_maybe_command($file);
diff --git a/lib/Module/Build/Platform/darwin.pm b/lib/Module/Build/Platform/darwin.pm
index c2f3126..d638f2d 100644
--- a/lib/Module/Build/Platform/darwin.pm
+++ b/lib/Module/Build/Platform/darwin.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::darwin;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Platform::Unix;
 
diff --git a/lib/Module/Build/Platform/os2.pm b/lib/Module/Build/Platform/os2.pm
index be164ae..b6b5956 100644
--- a/lib/Module/Build/Platform/os2.pm
+++ b/lib/Module/Build/Platform/os2.pm
@@ -2,7 +2,7 @@ package Module::Build::Platform::os2;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use Module::Build::Platform::Unix;
 
diff --git a/lib/Module/Build/PodParser.pm b/lib/Module/Build/PodParser.pm
index 225450c..faad4dd 100644
--- a/lib/Module/Build/PodParser.pm
+++ b/lib/Module/Build/PodParser.pm
@@ -2,7 +2,7 @@ package Module::Build::PodParser;
 
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 use vars qw(@ISA);
 
diff --git a/lib/Module/Build/Version.pm b/lib/Module/Build/Version.pm
index 21abe00..0917bbf 100644
--- a/lib/Module/Build/Version.pm
+++ b/lib/Module/Build/Version.pm
@@ -2,7 +2,7 @@ package Module::Build::Version;
 use strict;
 
 use vars qw($VERSION);
-$VERSION = 0.77;
+$VERSION = 0.82;
 
 eval "use version $VERSION";
 if ($@) { # can't locate version files, use our own
@@ -48,7 +48,7 @@ use strict;
 
 use vars qw(@ISA $VERSION $CLASS *declare *qv);
 
-$VERSION = 0.77;
+$VERSION = 0.82;
 
 $CLASS = 'version';
 
@@ -115,21 +115,130 @@ sub import {
 1;
 
 # replace everything from here to the end with the current version/vpp.pm
+package charstar;
+# a little helper class to emulate C char* semantics in Perl
+# so that prescan_version can use the same code as in C
+
+use overload (
+    '""'	=> \&thischar,
+    '0+'	=> \&thischar,
+    '++'	=> \&increment,
+    '--'	=> \&decrement,
+    '+'		=> \&plus,
+    '-'		=> \&minus,
+    '*'		=> \&multiply,
+    'cmp'	=> \&cmp,
+    '<=>'	=> \&spaceship,
+    'bool'	=> \&thischar,
+    '='		=> \&clone,
+);
+
+sub new {
+    my ($self, $string) = @_;
+    my $class = ref($self) || $self;
+
+    my $obj = {
+	string  => [split(//,$string)],
+	current => 0,
+    };
+    return bless $obj, $class;
+}
+
+sub thischar {
+    my ($self) = @_;
+    my $last = $#{$self->{string}};
+    my $curr = $self->{current};
+    if ($curr >= 0 && $curr <= $last) {
+	return $self->{string}->[$curr];
+    }
+    else {
+	return '';
+    }
+}
+
+sub increment {
+    my ($self) = @_;
+    $self->{current}++;
+}
+
+sub decrement {
+    my ($self) = @_;
+    $self->{current}--;
+}
+
+sub plus {
+    my ($self, $offset) = @_;
+    my $rself = $self->clone;
+    $rself->{current} += $offset;
+    return $rself;
+}
+
+sub minus {
+    my ($self, $offset) = @_;
+    my $rself = $self->clone;
+    $rself->{current} -= $offset;
+    return $rself;
+}
+
+sub multiply {
+    my ($left, $right, $swapped) = @_;
+    my $char = $left->thischar();
+    return $char * $right;
+}
+
+sub spaceship {
+    my ($left, $right, $swapped) = @_;
+    unless (ref($right)) { # not an object already
+	$right = $left->new($right);
+    }
+    return $left->{current} <=> $right->{current};
+}
+
+sub cmp {
+    my ($left, $right, $swapped) = @_;
+    unless (ref($right)) { # not an object already
+	if (length($right) == 1) { # comparing single character only
+	    return $left->thischar cmp $right;
+	}
+	$right = $left->new($right);
+    }
+    return $left->currstr cmp $right->currstr;
+}
+
+sub bool {
+    my ($self) = @_;
+    my $char = $self->thischar;
+    return ($char ne '');
+}
+
+sub clone {
+    my ($left, $right, $swapped) = @_;
+    $right = {
+	string  => [@{$left->{string}}],
+	current => $left->{current},
+    };
+    return bless $right, ref($left);
+}
+
+sub currstr {
+    my ($self, $s) = @_;
+    my $curr = $self->{current};
+    my $last = $#{$self->{string}};
+    if (defined($s) && $s->{current} < $last) {
+	$last = $s->{current};
+    }
+
+    my $string = join('', @{$self->{string}}[$curr..$last]);
+    return $string;
+}
+
 package version::vpp;
 use strict;
 
 use POSIX qw/locale_h/;
 use locale;
 use vars qw ($VERSION @ISA @REGEXS);
-$VERSION = '0.77';
-$VERSION = eval $VERSION;
-
-push @REGEXS, qr/
-	^v?	# optional leading 'v'
-	(\d*)	# major revision not required
-	\.	# requires at least one decimal
-	(?:(\d+)\.?){1,}
-	/x;
+$VERSION = 0.82;
 
 use overload (
     '""'       => \&stringify,
@@ -140,8 +249,6 @@ use overload (
     'nomethod' => \&vnoop,
 );
 
-my $VERSION_MAX = 0x7FFFFFFF;
-
 eval "use warnings";
 if ($@) {
     eval '
@@ -151,248 +258,467 @@ if ($@) {
     ';
 }
 
-sub new
-{
-	my ($class, $value) = @_;
-	my $self = bless ({}, ref ($class) || $class);
+my $VERSION_MAX = 0x7FFFFFFF;
 
-	if ( ref($value) && eval('$value->isa("version")') ) {
-	    # Can copy the elements directly
-	    $self->{version} = [ @{$value->{version} } ];
-	    $self->{qv} = 1 if $value->{qv};
-	    $self->{alpha} = 1 if $value->{alpha};
-	    $self->{original} = ''.$value->{original};
-	    return $self;
-	}
+# implement prescan_version as closely to the C version as possible
+use constant TRUE  => 1;
+use constant FALSE => 0;
 
-	my $currlocale = setlocale(LC_ALL);
+sub isDIGIT {
+    my ($char) = shift->thischar();
+    return ($char =~ /\d/);
+}
 
-	# if the current locale uses commas for decimal points, we
-	# just replace commas with decimal places, rather than changing
-	# locales
-	if ( localeconv()->{decimal_point} eq ',' ) {
-	    $value =~ tr/,/./;
-	}
+sub isALPHA {
+    my ($char) = shift->thischar();
+    return ($char =~ /[a-zA-Z]/);
+}
 
-	if ( not defined $value or $value =~ /^undef$/ ) {
-	    # RT #19517 - special case for undef comparison
-	    # or someone forgot to pass a value
-	    push @{$self->{version}}, 0;
-	    $self->{original} = "0";
-	    return ($self);
-	}
+sub isSPACE {
+    my ($char) = shift->thischar();
+    return ($char =~ /\s/);
+}
 
-	if ( $#_ == 2 ) { # must be CVS-style
-	    $value = 'v'.$_[2];
-	}
+sub BADVERSION {
+    my ($s, $errstr, $error) = @_;
+    if ($errstr) {
+	$$errstr = $error;
+    }
+    return $s;
+}
 
-	$value = _un_vstring($value);
+sub prescan_version {
+    my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
+    my $qv          = defined $sqv          ? $$sqv          : FALSE;
+    my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
+    my $width       = defined $swidth       ? $$swidth       : 3;
+    my $alpha       = defined $salpha       ? $$salpha       : FALSE;
 
-	# exponential notation
-	if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
-	    $value = sprintf("%.9f",$value);
-	    $value =~ s/(0+)$//; # trim trailing zeros
-	}
+    my $d = $s;
 
-	# This is not very efficient, but it is morally equivalent
-	# to the XS code (as that is the reference implementation).
-	# See vutil/vutil.c for details
-	my $qv = 0;
-	my $alpha = 0;
-	my $width = 3;
-	my $saw_period = 0;
-	my $vinf = 0;
-	my ($start, $last, $pos, $s);
-	$s = 0;
+    if ($qv && isDIGIT($d)) {
+	goto dotted_decimal_version;
+    }
 
-	while ( substr($value,$s,1) =~ /\s/ ) { # leading whitespace is OK
-	    $s++;
+    if ($d eq 'v') { # explicit v-string
+	$d++;
+	if (isDIGIT($d)) {
+	    $qv = TRUE;
+	}
+	else { # degenerate v-string
+	    # requires v1.2.3
+	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
 	}
 
-	if (substr($value,$s,1) eq 'v') {
-	    $s++;    # get past 'v'
-	    $qv = 1; # force quoted version processing
+dotted_decimal_version:
+	if ($strict && $d eq '0' && isDIGIT($d+1)) {
+	    # no leading zeros allowed
+	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
 	}
 
-	$start = $last = $pos = $s;
+	while (isDIGIT($d)) { 	# integer part
+	    $d++;
+	}
 
-	# pre-scan the input string to check for decimals/underbars
-	while ( substr($value,$pos,1) =~ /[._\d,]/ ) {
-	    if ( substr($value,$pos,1) eq '.' ) {
-		if ($alpha) {
-		    Carp::croak("Invalid version format ".
-		      "(underscores before decimal)");
-		}
-		$saw_period++;
-		$last = $pos;
+	if ($d eq '.')
+	{
+	    $saw_decimal++;
+	    $d++; 		# decimal point
+	}
+	else
+	{
+	    if ($strict) {
+		# require v1.2.3
+		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
 	    }
-	    elsif ( substr($value,$pos,1) eq '_' ) {
-		if ($alpha) {
-		    require Carp;
-		    Carp::croak("Invalid version format ".
-			"(multiple underscores)");
+	    else {
+		goto version_prescan_finish;
+	    }
+	}
+
+	{
+	    my $i = 0;
+	    my $j = 0;
+	    while (isDIGIT($d)) {	# just keep reading
+		$i++;
+		while (isDIGIT($d)) {
+		    $d++; $j++;
+		    # maximum 3 digits between decimal
+		    if ($strict && $j > 3) {
+			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
+		    }
 		}
-		$alpha = 1;
-		$width = $pos - $last - 1; # natural width of sub-version
+		if ($d eq '_') {
+		    if ($strict) {
+			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
+		    }
+		    if ( $alpha ) {
+			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
+		    }
+		    $d++;
+		    $alpha = TRUE;
+		}
+		elsif ($d eq '.') {
+		    if ($alpha) {
+			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
+		    }
+		    $saw_decimal++;
+		    $d++;
+		}
+		elsif (!isDIGIT($d)) {
+		    last;
+		}
+		$j = 0;
 	    }
-	    elsif ( substr($value,$pos,1) eq ','
-		    and substr($value,$pos+1,1) =~ /[0-9]/ ) {
-		# looks like an unhandled locale
-		$saw_period++;
-		$last = $pos;
+	
+	    if ($strict && $i < 2) {
+		# requires v1.2.3
+		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
 	    }
-	    $pos++;
 	}
-
-	if ( $alpha && !$saw_period ) {
-	    require Carp;
-	    Carp::croak("Invalid version format ".
-		"(alpha without decimal)");
+    } 					# end if dotted-decimal
+    else
+    {					# decimal versions
+	# special $strict case for leading '.' or '0'
+	if ($strict) {
+	    if ($d eq '.') {
+		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
+	    }
+	    if ($d eq '0' && isDIGIT($d+1)) {
+		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
+	    }
 	}
 
-	if ( $alpha && $saw_period && $width == 0 ) {
-	    require Carp;
-	    Carp::croak("Invalid version format ".
-		"(misplaced _ in number)");
+	# consume all of the integer part
+	while (isDIGIT($d)) {
+	    $d++;
 	}
 
-	if ( $saw_period > 1 ) {
-	    $qv = 1; # force quoted version processing
+	# look for a fractional part
+	if ($d eq '.') {
+	    # we found it, so consume it
+	    $saw_decimal++;
+	    $d++;
 	}
-
-	$last = $pos;
-	$pos = $s;
-
-	if ( $qv ) {
-	    $self->{qv} = 1;
+	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
+	    if ( $d == $s ) {
+		# found nothing
+		return BADVERSION($s,$errstr,"Invalid version format (version required)");
+	    }
+	    # found just an integer
+	    goto version_prescan_finish;
+	}
+	elsif ( $d == $s ) {
+	    # didn't find either integer or period
+	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
+	}
+	elsif ($d eq '_') {
+	    # underscore can't come after integer part
+	    if ($strict) {
+		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
+	    }
+	    elsif (isDIGIT($d+1)) {
+		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
+	    }
+	    else {
+		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
+	    }
+	}
+	elsif ($d) {
+	    # anything else after integer part is just invalid data
+	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
 	}
 
-	if ( $alpha ) {
-	    $self->{alpha} = 1;
-	}
-
-	if ( !$qv && $width < 3 ) {
-	    $self->{width} = $width;
-	}
-
-	while ( substr($value,$pos,1) =~ /\d/ ) {
-	    $pos++;
-	}
-
-	if ( substr($value,$pos,1) !~ /[a-z]/ ) { ### FIX THIS ###
-	    my $rev;
-
-	    while (1) {
-		$rev = 0;
-		{
-
-		    # this is atoi() that delimits on underscores
-		    my $end = $pos;
-		    my $mult = 1;
-		    my $orev;
-
-		    # the following if() will only be true after the decimal
-		    # point of a version originally created with a bare
-		    # floating point number, i.e. not quoted in any way
-		    if ( !$qv && $s > $start && $saw_period == 1 ) {
-			$mult *= 100;
-			while ( $s < $end ) {
-			    $orev = $rev;
-			    $rev += substr($value,$s,1) * $mult;
-			    $mult /= 10;
-			    if (   abs($orev) > abs($rev)
-				|| abs($rev) > abs($VERSION_MAX) ) {
-				if ( warnings::enabled("overflow") ) {
-				    require Carp;
-				    Carp::carp("Integer overflow in version");
-				}
-				$s = $end - 1;
-				$rev = $VERSION_MAX;
-			    }
-			    $s++;
-			    if ( substr($value,$s,1) eq '_' ) {
-				$s++;
-			    }
-			}
-		    }
-		    else {
-			while (--$end >= $s) {
-			    $orev = $rev;
-			    $rev += substr($value,$end,1) * $mult;
-			    $mult *= 10;
-			    if (   abs($orev) > abs($rev)
-				|| abs($rev) > abs($VERSION_MAX) ) {
-				if ( warnings::enabled("overflow") ) {
-				    require Carp;
-				    Carp::carp("Integer overflow in version");
-				}
-				$end = $s - 1;
-				$rev = $VERSION_MAX;
-			    }
-			}
-		    }
-		}
+	# scan the fractional part after the decimal point
+	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
+		# $strict or lax-but-not-the-end
+		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
+	}
 
-		# Append revision
-		push @{$self->{version}}, $rev;
-		if ( substr($value,$pos,1) eq '.'
-		    && substr($value,$pos+1,1) =~ /\d/ ) {
-		    $s = ++$pos;
-		}
-		elsif ( substr($value,$pos,1) eq '_'
-		    && substr($value,$pos+1,1) =~ /\d/ ) {
-		    $s = ++$pos;
+	while (isDIGIT($d)) {
+	    $d++;
+	    if ($d eq '.' && isDIGIT($d-1)) {
+		if ($alpha) {
+		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
 		}
-		elsif ( substr($value,$pos,1) eq ','
-		    && substr($value,$pos+1,1) =~ /\d/ ) {
-		    $s = ++$pos;
+		if ($strict) {
+		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
 		}
-		elsif ( substr($value,$pos,1) =~ /\d/ ) {
-		    $s = $pos;
+		$d = $s; # start all over again
+		$qv = TRUE;
+		goto dotted_decimal_version;
+	    }
+	    if ($d eq '_') {
+		if ($strict) {
+		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
 		}
-		else {
-		    $s = $pos;
-		    last;
+		if ( $alpha ) {
+		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
 		}
-		if ( $qv ) {
-		    while ( substr($value,$pos,1) =~ /\d/ ) {
-			$pos++;
-		    }
+		if ( ! isDIGIT($d+1) ) {
+		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
 		}
-		else {
-		    my $digits = 0;
-		    while (substr($value,$pos,1) =~ /[\d_]/ && $digits < 3) {
-			if ( substr($value,$pos,1) ne '_' ) {
-			    $digits++;
+		$d++;
+		$alpha = TRUE;
+	    }
+	}
+    }
+
+version_prescan_finish:
+    while (isSPACE($d)) {
+	$d++;
+    }
+
+    if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
+	# trailing non-numeric data
+	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
+    }
+
+    if (defined $sqv) {
+	$$sqv = $qv;
+    }
+    if (defined $swidth) {
+	$$swidth = $width;
+    }
+    if (defined $ssaw_decimal) {
+	$$ssaw_decimal = $saw_decimal;
+    }
+    if (defined $salpha) {
+	$$salpha = $alpha;
+    }
+    return $d;
+}
+
+sub scan_version {
+    my ($s, $rv, $qv) = @_;
+    my $start;
+    my $pos;
+    my $last;
+    my $errstr;
+    my $saw_decimal = 0;
+    my $width = 3;
+    my $alpha = FALSE;
+    my $vinf = FALSE;
+    my @av;
+
+    $s = new charstar $s;
+
+    while (isSPACE($s)) { # leading whitespace is OK
+	$s++;
+    }
+
+    $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
+	\$width, \$alpha);
+
+    if ($errstr) {
+	# 'undef' is a special case and not an error
+	if ( $s ne 'undef') {
+	    use Carp;
+	    Carp::croak($errstr);
+	}
+    }
+
+    $start = $s;
+    if ($s eq 'v') {
+	$s++;
+    }
+    $pos = $s;
+
+    if ( $qv ) {
+	$$rv->{qv} = $qv;
+    }
+    if ( $alpha ) {
+	$$rv->{alpha} = $alpha;
+    }
+    if ( !$qv && $width < 3 ) {
+	$$rv->{width} = $width;
+    }
+    
+    while (isDIGIT($pos)) {
+	$pos++;
+    }
+    if (!isALPHA($pos)) {
+	my $rev;
+
+	for (;;) {
+	    $rev = 0;
+	    {
+  		# this is atoi() that delimits on underscores
+  		my $end = $pos;
+  		my $mult = 1;
+		my $orev;
+
+		#  the following if() will only be true after the decimal
+		#  point of a version originally created with a bare
+		#  floating point number, i.e. not quoted in any way
+		#
+ 		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
+		    $mult *= 100;
+ 		    while ( $s < $end ) {
+			$orev = $rev;
+ 			$rev += $s * $mult;
+ 			$mult /= 10;
+			if (   (abs($orev) > abs($rev)) 
+			    || (abs($rev) > $VERSION_MAX )) {
+			    warn("Integer overflow in version %d",
+					   $VERSION_MAX);
+			    $s = $end - 1;
+			    $rev = $VERSION_MAX;
+			    $vinf = 1;
+			}
+ 			$s++;
+			if ( $s eq '_' ) {
+			    $s++;
 			}
-			$pos++;
+ 		    }
+  		}
+ 		else {
+ 		    while (--$end >= $s) {
+			$orev = $rev;
+ 			$rev += $end * $mult;
+ 			$mult *= 10;
+			if (   (abs($orev) > abs($rev)) 
+			    || (abs($rev) > $VERSION_MAX )) {
+			    warn("Integer overflow in version");
+			    $end = $s - 1;
+			    $rev = $VERSION_MAX;
+			    $vinf = 1;
+			}
+ 		    }
+ 		} 
+  	    }
+
+  	    # Append revision
+	    push @av, $rev;
+	    if ( $vinf ) {
+		$s = $last;
+		last;
+	    }
+	    elsif ( $pos eq '.' ) {
+		$s = ++$pos;
+	    }
+	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
+		$s = ++$pos;
+	    }
+	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
+		$s = ++$pos;
+	    }
+	    elsif ( isDIGIT($pos) ) {
+		$s = $pos;
+	    }
+	    else {
+		$s = $pos;
+		last;
+	    }
+	    if ( $qv ) {
+		while ( isDIGIT($pos) ) {
+		    $pos++;
+		}
+	    }
+	    else {
+		my $digits = 0;
+		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
+		    if ( $pos ne '_' ) {
+			$digits++;
 		    }
+		    $pos++;
 		}
 	    }
 	}
-	if ( $qv ) { # quoted versions always get at least three terms
-	    my $len = scalar @{$self->{version}};
-	    $len = 3 - $len;
-	    while ($len-- > 0) {
-		push @{$self->{version}}, 0;
-	    }
+    }
+    if ( $qv ) { # quoted versions always get at least three terms
+	my $len = $#av;
+	#  This for loop appears to trigger a compiler bug on OS X, as it
+	#  loops infinitely. Yes, len is negative. No, it makes no sense.
+	#  Compiler in question is:
+	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
+	#  for ( len = 2 - len; len > 0; len-- )
+	#  av_push(MUTABLE_AV(sv), newSViv(0));
+	# 
+	$len = 2 - $len;
+	while ($len-- > 0) {
+	    push @av, 0;
 	}
+    }
 
-	if ( substr($value,$pos) ) { # any remaining text
-	    if ( warnings::enabled("misc") ) {
-		require Carp;
-		Carp::carp("Version string '$value' contains invalid data; ".
-		     "ignoring: '".substr($value,$pos)."'");
-	    }
+    # need to save off the current version string for later
+    if ( $vinf ) {
+	$$rv->{original} = "v.Inf";
+	$$rv->{vinf} = 1;
+    }
+    elsif ( $s > $start ) {
+	$$rv->{original} = $start->currstr($s);
+	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
+	    # need to insert a v to be consistent
+	    $$rv->{original} = 'v' . $$rv->{original};
 	}
+    }
+    else {
+	$$rv->{original} = '0';
+	push(@av, 0);
+    }
+
+    # And finally, store the AV in the hash
+    $$rv->{version} = \@av;
 
-	# cache the original value for use when stringification
-	if ( $vinf ) {
-	    $self->{vinf} = 1;
-	    $self->{original} = 'v.Inf';
+    # fix RT#19517 - special case 'undef' as string
+    if ($s eq 'undef') {
+	$s += 5;
+    }
+
+    return $s;
+}
+
+sub new
+{
+	my ($class, $value) = @_;
+	my $self = bless ({}, ref ($class) || $class);
+	my $qv = FALSE;
+	
+	if ( ref($value) && eval('$value->isa("version")') ) {
+	    # Can copy the elements directly
+	    $self->{version} = [ @{$value->{version} } ];
+	    $self->{qv} = 1 if $value->{qv};
+	    $self->{alpha} = 1 if $value->{alpha};
+	    $self->{original} = ''.$value->{original};
+	    return $self;
 	}
-	else {
-	    $self->{original} = substr($value,0,$pos);
+
+	my $currlocale = setlocale(LC_ALL);
+
+	# if the current locale uses commas for decimal points, we
+	# just replace commas with decimal places, rather than changing
+	# locales
+	if ( localeconv()->{decimal_point} eq ',' ) {
+	    $value =~ tr/,/./;
+	}
+
+	if ( not defined $value or $value =~ /^undef$/ ) {
+	    # RT #19517 - special case for undef comparison
+	    # or someone forgot to pass a value
+	    push @{$self->{version}}, 0;
+	    $self->{original} = "0";
+	    return ($self);
+	}
+
+	if ( $#_ == 2 ) { # must be CVS-style
+	    $value = $_[2];
+	    $qv = TRUE;
+	}
+
+	$value = _un_vstring($value);
+
+	# exponential notation
+	if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
+	    $value = sprintf("%.9f",$value);
+	    $value =~ s/(0+)$//; # trim trailing zeros
+	}
+	
+	my $s = scan_version($value, \$self, $qv);
+
+	if ($s) { # must be something left over
+	    warn("Version string '%s' contains invalid data; "
+                       ."ignoring: '%s'", $value, $s);
 	}
 
 	return ($self);
@@ -400,7 +726,7 @@ sub new
 
 *parse = \&new;
 
-sub numify
+sub numify 
 {
     my ($self) = @_;
     unless (_verify($self)) {
@@ -441,7 +767,7 @@ sub numify
     return $string;
 }
 
-sub normal
+sub normal 
 {
     my ($self) = @_;
     unless (_verify($self)) {
@@ -484,9 +810,9 @@ sub stringify
 	require Carp;
 	Carp::croak("Invalid version object");
     }
-    return exists $self->{original}
-    	? $self->{original}
-	: exists $self->{qv}
+    return exists $self->{original} 
+    	? $self->{original} 
+	: exists $self->{qv} 
 	    ? $self->normal
 	    : $self->numify;
 }
@@ -524,8 +850,8 @@ sub vcmp
     }
 
     # tiebreaker for alpha with identical terms
-    if ( $retval == 0
-	&& $l == $r
+    if ( $retval == 0 
+	&& $l == $r 
 	&& $left->{version}[$m] == $right->{version}[$m]
 	&& ( $lalpha || $ralpha ) ) {
 
@@ -557,7 +883,7 @@ sub vcmp
 	}
     }
 
-    return $retval;
+    return $retval;  
 }
 
 sub vbool {
@@ -565,8 +891,8 @@ sub vbool {
     return vcmp($self,$self->new("0"),1);
 }
 
-sub vnoop {
-    require Carp;
+sub vnoop { 
+    require Carp; 
     Carp::croak("operation not supported with version object");
 }
 
@@ -613,11 +939,17 @@ sub _verify {
 sub _un_vstring {
     my $value = shift;
     # may be a v-string
-    if ( $] >= 5.006_000 && length($value) >= 3 && $value !~ /[._]/ ) {
-	my $tvalue = sprintf("v%vd",$value);
-	if ( $tvalue =~ /^v\d+\.\d+\.\d+$/ ) {
-	    # must be a v-string
-	    $value = $tvalue;
+    if ( $] >= 5.006_000 && length($value) >= 3 && $value !~ /[._]/) {
+	foreach my $char (split(//,$value)) {
+	    # if one of the characters is non-text assume v-string
+	    if (ord($char) < ord(" ")) {
+		my $tvalue = sprintf("v%vd",$value);
+		if ( $tvalue =~ /^v\d+(\.\d+){2,}$/ ) {
+		    # must be a v-string
+		    $value = $tvalue;
+		}
+		last;
+	    }
 	}
     }
     return $value;
@@ -644,7 +976,7 @@ sub _VERSION {
     if ( defined $req ) {
 	unless ( defined $version ) {
 	    require Carp;
-	    my $msg =  $] < 5.006
+	    my $msg =  $] < 5.006 
 	    ? "$class version $req required--this is only version "
 	    : "$class does not define \$$class\::VERSION"
 	      ."--version check failed";
@@ -662,14 +994,14 @@ sub _VERSION {
 	if ( $req > $version ) {
 	    require Carp;
 	    if ( $req->is_qv ) {
-		Carp::croak(
+		Carp::croak( 
 		    sprintf ("%s version %s required--".
 			"this is only version %s", $class,
 			$req->normal, $version->normal)
 		);
 	    }
 	    else {
-		Carp::croak(
+		Carp::croak( 
 		    sprintf ("%s version %s required--".
 			"this is only version %s", $class,
 			$req->stringify, $version->stringify)
diff --git a/lib/inc/latest.pm b/lib/inc/latest.pm
index fc9e2e9..ffc9ce2 100644
--- a/lib/inc/latest.pm
+++ b/lib/inc/latest.pm
@@ -1,7 +1,7 @@
 package inc::latest;
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 
 use Carp;
diff --git a/lib/inc/latest/private.pm b/lib/inc/latest/private.pm
index 572ae8a..6aa7df7 100644
--- a/lib/inc/latest/private.pm
+++ b/lib/inc/latest/private.pm
@@ -1,7 +1,7 @@
 package inc::latest::private;
 use strict;
 use vars qw($VERSION);
-$VERSION = '0.3603';
+$VERSION = '0.36_13';
 $VERSION = eval $VERSION;
 
 use File::Spec;
diff --git a/t/actions/manifest_skip.t b/t/actions/manifest_skip.t
new file mode 100644
index 0000000..a3677dd
--- /dev/null
+++ b/t/actions/manifest_skip.t
@@ -0,0 +1,54 @@
+use strict;
+use lib 't/lib';
+use MBTest;
+use DistGen;
+
+plan tests => 7;
+
+# Ensure any Module::Build modules are loaded from correct directory
+blib_load('Module::Build');
+
+# create dist object in a temp directory
+# enter the directory and generate the skeleton files
+my $dist = DistGen->new->chdir_in;
+$dist->change_build_pl(
+  module_name => $dist->name,
+  requires => {
+    'File::Spec' => 9999,
+  },
+  build_requires => {
+    'Getopt::Long' => 9998,
+  },
+  cpan_client => $^X . ' -le print($_)for($^X,@ARGV)',
+)->regen;
+
+ok( ! -e 'MANIFEST.SKIP', "MANIFEST.SKIP doesn't exist at start" );
+
+# get a Module::Build object and test with it
+my $mb;
+stdout_stderr_of( sub { $mb = $dist->new_from_context('verbose' => 1) } );
+isa_ok( $mb, "Module::Build" );
+
+my ($out, $err) = stdout_stderr_of( sub {
+    $dist->run_build('manifest_skip')
+});
+ok( -e 'MANIFEST.SKIP', "'Build manifest_skip' creates MANIFEST.SKIP" );
+like( $out, qr/Creating a new MANIFEST.SKIP file/, "Saw creation message");
+
+# shouldn't overwrite
+my $old_mtime = -M 'MANIFEST.SKIP';
+($out, $err) = stdout_stderr_of( sub {
+    $dist->run_build('manifest_skip')
+});
+like( $err, qr/MANIFEST.SKIP already exists/, 
+  "Running it again warns about pre-existing MANIFEST.SKIP"
+);
+is( -M 'MANIFEST.SKIP', $old_mtime, "File does not appear modified" );
+
+# cleanup
+($out, $err) = stdout_stderr_of( sub {
+    $dist->run_build('distclean')
+});
+ok( -e 'MANIFEST.SKIP', "MANIFEST.SKIP still exists after distclean" );
+
+# vim:ts=2:sw=2:et:sta:sts=2
diff --git a/t/basic.t b/t/basic.t
index 5d76ffa..e26847e 100644
--- a/t/basic.t
+++ b/t/basic.t
@@ -60,8 +60,8 @@ $dist->chdir_in;
   ok $flagged;
   ok $mb->prereq_failures;
   ok $mb->prereq_failures->{requires}{$dist->name};
-  is $mb->prereq_failures->{requires}{$dist->name}{have}, 0.01;
-  is $mb->prereq_failures->{requires}{$dist->name}{need}, 3.14159265;
+  is $mb->prereq_failures->{requires}{$dist->name}{have}, "0.01";
+  is $mb->prereq_failures->{requires}{$dist->name}{need}, "3.14159265";
 
   $mb->dispatch('realclean');
   $dist->clean;
diff --git a/t/compat.t b/t/compat.t
index 0a820a9..1546d2b 100644
--- a/t/compat.t
+++ b/t/compat.t
@@ -218,23 +218,25 @@ ok $mb, "Module::Build->new_from_context";
 
   (my $libdir2 = $libdir) =~ s/libdir/lbiidr/;
   my $libarch2 = File::Spec->catdir($libdir2, 'arch');
+  my $check_base = $libdir2;
+  $check_base =~ s/\]\z// if $^O eq 'VMS'; # trim trailing ] for appending other dirs
 
   SKIP: {
     my @cases = (
       {
         label => "INSTALLDIRS=vendor",
         args => [ 'INSTALLDIRS=vendor', "INSTALLVENDORLIB=$libdir2", "INSTALLVENDORARCH=$libarch2"],
-        check => qr/\Q$libdir2\E .* Simple\.pm/ix,
+        check => qr/\Q$check_base\E .* Simple\.pm/ix,
       },
       {
         label => "PREFIX=\$libdir2",
         args => [ "PREFIX=$libdir2"],
-        check => qr/\Q$libdir2\E .* Simple\.pm/ix,
+        check => qr/\Q$check_base\E .* Simple\.pm/ix,
       },
       {
         label => "PREFIX=\$libdir2 LIB=mylib",
         args => [ "PREFIX=$libdir2", "LIB=mylib" ],
-        check => qr{\Q$libdir2\E[/\\]mylib[/\\]Simple\.pm}ix,
+        check => qr{\Q$check_base\E[/\\\.]mylib[/\\\]]Simple\.pm}ix,
       },
     );
 
@@ -244,10 +246,6 @@ ok $mb, "Module::Build->new_from_context";
 
     for my $c (@cases) {
       my @make_args = @{$c->{args}};
-      if ($is_vms_mms) { # VMS MMK/MMS macros use different syntax.
-        $make_args[0] = '/macro=("' . join('","',@make_args) . '")';
-        pop @make_args while scalar(@make_args) > 1;
-      }
       ($output) = stdout_stderr_of(
         sub {
           $result = $mb->run_perl_script('Makefile.PL', [], \@make_args);
@@ -315,6 +313,63 @@ ok $mb, "Module::Build->new_from_context";
     ok( ! exists $args->{TESTS}, 'Not using incorrect recursive tests key' );
   }
 
+  1 while unlink 'Makefile.PL';
+  ok ! -e 'Makefile.PL', "Makefile.PL cleaned up";
+}
+
+{
+  # make sure using prereq with '0.1.2' complains
+  $dist->change_build_pl({
+    module_name         => $distname,
+    license             => 'perl',
+    requires            => {
+      'Foo::Frobnicate' => '0.1.2',
+    },
+    create_makefile_pl  => 'traditional',
+  });
+  $dist->regen;
+
+  my $mb;
+  stdout_stderr_of( sub {
+    $mb = Module::Build->new_from_context;
+  });
+
+  my $output = stdout_stderr_of( sub { $mb->do_create_makefile_pl } );
+  ok -e 'Makefile.PL', "Makefile.PL created";
+  like $output, qr/is not portable/, "Correctly complains and converts dotted-decimal";
+
+  my $file_contents = slurp 'Makefile.PL';
+  like $file_contents, qr/Foo::Frobnicate.+0\.001002/, "Properly converted dotted-decimal";
+
+  1 while unlink 'Makefile.PL';
+  ok ! -e 'Makefile.PL', "Makefile.PL cleaned up";
+}
+
+{
+  # make sure using invalid prereq blows up
+  $dist->change_build_pl({
+    module_name         => $distname,
+    license             => 'perl',
+    requires            => {
+      'Foo::Frobnicate' => '3.5_2_7',
+    },
+    create_makefile_pl  => 'traditional',
+  });
+  $dist->regen;
+
+  ok ! -e 'Makefile.PL', "Makefile.PL doesn't exist before we start";
+
+  my $mb;
+  stdout_stderr_of( sub {
+    $mb = $dist->run_build_pl;
+  });
+
+  my ($output, $error) = stdout_stderr_of( sub { $dist->run_build('distmeta') } );
+  like $error, qr/is not supported/ms, "Correctly dies when it encounters invalid prereq";
+  ok ! -e 'Makefile.PL', "Makefile.PL NOT created";
+
+  1 while unlink 'Makefile.PL';
+  ok ! -e 'Makefile.PL', "Makefile.PL cleaned up";
 }
 
 #########################################################
diff --git a/t/lib/MBTest.pm b/t/lib/MBTest.pm
index 6dc4c86..ec3c20f 100644
--- a/t/lib/MBTest.pm
+++ b/t/lib/MBTest.pm
@@ -12,6 +12,7 @@ use File::Path ();
 BEGIN {
     # Environment variables which might effect our testing
     my @delete_env_keys = qw(
+        HOME
         DEVEL_COVER_OPTIONS
         MODULEBUILDRC
         PERL_MB_OPT
@@ -96,7 +97,11 @@ __PACKAGE__->export(scalar caller, @extra_exports);
 
 # always return to the current directory
 {
-  my $cwd = File::Spec->rel2abs(Cwd::cwd);
+  my $cwd;
+  # must be done in BEGIN because tmpdir uses it in BEGIN for $ENV{HOME}
+  BEGIN { 
+    $cwd = File::Spec->rel2abs(Cwd::cwd);
+  }
 
   sub original_cwd { return $cwd }
 
@@ -123,6 +128,10 @@ sub tmpdir {
   return File::Temp::tempdir('MB-XXXXXXXX', CLEANUP => 1, DIR => $dir, @args);
 }
 
+BEGIN {
+  $ENV{HOME} = tmpdir; # don't want .modulebuildrc or other things interfering
+}
+
 sub save_handle {
   my ($handle, $subr) = @_;
   my $outfile = File::Spec->catfile(File::Spec->tmpdir, temp_file_name());
diff --git a/t/metadata.t b/t/metadata.t
index 1ac35b2..a495f15 100644
--- a/t/metadata.t
+++ b/t/metadata.t
@@ -2,7 +2,7 @@
 
 use strict;
 use lib 't/lib';
-use MBTest tests => 51;
+use MBTest tests => 52;
 
 blib_load('Module::Build');
 blib_load('Module::Build::ConfigData');
@@ -65,7 +65,13 @@ my $mb = Module::Build->new_from_context;
   my $mb_config_req = {
     'Module::Build' => int($Module::Build::VERSION * 100)/100
   };
-  my $node = $mb->get_metadata( );
+  my $node;
+  my $output = stdout_stderr_of( sub {
+    $node = $mb->get_metadata( auto => 1 );
+  });
+  like( $output, qr/Module::Build was not found in configure_requires/,
+    "saw warning about M::B not in configure_requires"
+  );
 
   # exists() doesn't seem to work here
   is $node->{name}, $metadata{module_name};
@@ -86,7 +92,7 @@ my $mb = Module::Build->new_from_context;
 {
   my $mb_prereq = { 'Module::Build' => 0 };
   $mb->configure_requires( $mb_prereq );
-  my $node = $mb->get_metadata( );
+  my $node = $mb->get_metadata( auto => 1 );
 
 
   # exists() doesn't seem to work here
diff --git a/t/moduleinfo.t b/t/moduleinfo.t
index e28726d..8e379d7 100644
--- a/t/moduleinfo.t
+++ b/t/moduleinfo.t
@@ -153,7 +153,7 @@ our $VERSION = '1.23_00_00';
 );
 my %modules = reverse @modules;
 
-plan tests => 36 + 2 * keys( %modules );
+plan tests => 39 + 2 * keys( %modules );
 
 blib_load('Module::Build::ModuleInfo');
 
@@ -438,3 +438,18 @@ $VERSION = version->new('0.61.' . (qw$Revision: 129 $)[1]);
   is( $pm_info->version('Simple::Simon'), '0.61.129', 'version for embedded package' );
 }
 
+{
+  # Make sure we handle illegal $VERSIONS
+  $dist->change_file( 'lib/Simple.pm', <<'---' );
+package Simple;
+our $VERSION = "ABC";
+---
+  $dist->regen;
+  my $warning;
+  local $SIG{__WARN__} = sub { $warning = shift };
+  $pm_info = Module::Build::ModuleInfo->new_from_file('lib/Simple.pm');
+  like( $warning, qr/does not appear to be valid/, "Got warning on bad version" );
+  is( $pm_info->name, 'Simple', 'found default package' );
+  is( $pm_info->version, undef, "invalid version returned as undef" );
+
+}
diff --git a/t/mymeta.t b/t/mymeta.t
index 91a2690..994b258 100644
--- a/t/mymeta.t
+++ b/t/mymeta.t
@@ -3,7 +3,7 @@
 use strict;
 use lib 't/lib';
 use MBTest;
-plan tests => 24;
+plan tests => 25;
 
 blib_load('Module::Build');
 blib_load('Module::Build::YAML');
@@ -47,15 +47,21 @@ $dist->chdir_in;
 
 # Test interactions between META/MYMETA
 {
-  my $output = stdout_of sub { $dist->run_build('distmeta') };
+  my $output = stdout_stderr_of sub { $dist->run_build('distmeta') };
   like($output, qr/Creating META.yml/,
     "Ran Build distmeta to create META.yml");
+  # regenerate MYMETA to pick up from META instead of creating from scratch
+  $output = stdout_of sub { $dist->run_build_pl };
+  like($output, qr/Creating new 'MYMETA.yml' with configuration results/,
+    "Re-ran Build.PL and regenerated MYMETA.yml based on META.yml"
+  );
+
   my $meta = Module::Build::YAML->read('META.yml')->[0];
   my $mymeta = Module::Build::YAML->read('MYMETA.yml')->[0];
   is( delete $mymeta->{dynamic_config}, 0,
     "MYMETA 'dynamic_config' is 0"
   );
-  is_deeply( $meta, $mymeta, "Other generated MYMETA matches generated META" );
+  is_deeply( $mymeta, $meta, "Other generated MYMETA matches generated META" );
   $output = stdout_stderr_of sub { $dist->run_build('realclean') };
   like( $output, qr/Cleaning up/, "Ran realclean");
   ok( ! -e 'Build', "Build file removed" );
diff --git a/t/properties/share_dir.t b/t/properties/share_dir.t
index 8cf961d..1d81a0a 100644
--- a/t/properties/share_dir.t
+++ b/t/properties/share_dir.t
@@ -179,6 +179,11 @@ ok( -d 'blib/lib/auto/share', "blib/lib/auto/share exists" );
 
 my $share_list = Module::Build->rscan_dir('blib/lib/auto/share', sub {-f});
 
+SKIP:
+{
+
+skip 'filename case not necessarily preserved', 1 if $^O eq 'VMS';
+
 is_deeply(
   [ sort @$share_list ], [
     'blib/lib/auto/share/dist/Simple-Share/foo.txt',
@@ -187,6 +192,8 @@ is_deeply(
   "share_dir files copied to blib"
 );
 
+}
+
 #--------------------------------------------------------------------------#
 # test installing
 #--------------------------------------------------------------------------#
@@ -202,6 +209,11 @@ $share_list = Module::Build->rscan_dir(
   "$temp_install/lib/perl5/auto/share", sub {-f}
 );
 
+SKIP:
+{
+
+skip 'filename case not necessarily preserved', 1 if $^O eq 'VMS';
+
 is_deeply(
   [ sort @$share_list ], [
     "$temp_install/lib/perl5/auto/share/dist/Simple-Share/foo.txt",
@@ -210,6 +222,8 @@ is_deeply(
   "share_dir files correctly installed"
 );
 
+}
+
 #--------------------------------------------------------------------------#
 # test with File::ShareDir
 #--------------------------------------------------------------------------#
diff --git a/t/runthrough.t b/t/runthrough.t
index 9e8d52e..6b8d3ae 100644
--- a/t/runthrough.t
+++ b/t/runthrough.t
@@ -110,14 +110,14 @@ SKIP: {
   skip( 'YAML_support feature is not enabled', 7 ) unless $have_yaml;
 
   my $output = eval {
-    stdout_of( sub { $mb->dispatch('disttest') } )
+    stdout_stderr_of( sub { $mb->dispatch('disttest') } )
   };
   is $@, '';
 
   # After a test, the distdir should contain a blib/ directory
   ok -e File::Spec->catdir('Simple-0.01', 'blib');
 
-  eval {$mb->dispatch('distdir')};
+  stdout_stderr_of ( sub { eval {$mb->dispatch('distdir')} } );
   is $@, '';
 
   # The 'distdir' should contain a lib/ directory
diff --git a/t/script_dist.t b/t/script_dist.t
index 7fd82d9..8db0006 100644
--- a/t/script_dist.t
+++ b/t/script_dist.t
@@ -68,7 +68,9 @@ is($mb->dist_name, 'bin-foo');
 is($mb->dist_version, '0.01');
 is_deeply($mb->dist_author,
   ['A. U. Thor, a.u.thor@a.galaxy.far.far.away']);
-ok $mb->dispatch('distmeta');
+my $result;
+stdout_stderr_of( sub { $result = $mb->dispatch('distmeta') } );
+ok $result;
 
 SKIP: {
   skip( 'YAML_support feature is not enabled', 1 )
