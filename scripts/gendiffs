#!/bin/bash

# running under bashdb has become impossible (due to
# extreme slowness) so we have to use the
# _Dbg_debugger hack if we want it.
if [[ "$GENDIFFS_DEBUG" ]] ; then
	source /usr/share/bashdb/bashdb-trace --
fi

gendiffs_eprefix=${EPREFIX:-/g2pfx}

# FIXME: big ugly assumption: overlay is a subdirectory of EPREFIX and so is portage
gendiffs_portage_tree=usr/portage
gendiffs_overlay=overlay
gendiffs_portage_diffs=portage_diffs

# The idea of this script is to capture the essential differences between the
# portage tree (presumed to be in ${gendiffs_eprefix}/${gendiffs_portage_tree} and this overlay.
# That way when we emerge --sync or w/e and everything changes, we are hopefully
# not left scratching our heads wondering what in our overlay is novel and what
# in our overlay is simply out of date.

# Perhaps there is already a tool or three that does this better?

# what we are trying to capture:
#
# o Files that exist in the overlay and in the installed portage tree, which
#   differ from the portage tree.
#
# o Files that don't exist upstream (we just want to name them)
#
# o .patch files that conflict with .patch files in portage.  This is not the
#   way we want to go with our overlay because patches of patches is a retarded
#   and useless brainpower-sucking waste, like spewing semantic chloroflourocarbons
#   into the FOSS atmosphere.  So we treat this as a conflict/error.
#
# o Files that were removed from analogous directories upstream
#
# That's all I can think of.
#
# This does not replace the VCS... it's simply there to allow my feeble brain to
# keep track of who is to blame for the deltas I see between upstream and my
# overlay: me, hacking away without a care, or Gentoo Devs, presumably doing the
# same.

_portage="${gendiffs_eprefix%/}"/${gendiffs_portage_tree}
_overlay="${gendiffs_eprefix%/}"/${gendiffs_overlay}
_portage_diffs="${_overlay}"/${gendiffs_portage_diffs}
gendiffs_datetime="$( date "+%Y%m%d-%H%M" )"
gendiffs_outdir="${_portage_diffs}"/latest
declare -a dirs
gendiffs_outfile=/dev/null
only_in_overlay_output=
only_in_portage_output=

usage() {
	echo "${0}: [-c|--clean] [-h|--help]"
	echo
	echo "--clean: remove all backups before creating the new one"
	echo "         unless the environment variable \"KEEP2\" is"
	echo "         exported and nonempty in which case all but the"
	echo "         two most recent backups are wiped."
	echo
}

if [[ $1 == -h || $1 == --help || $2 == -h || $2 == --help ]] ; then
	usage
	exit 0
fi

mkdir -p "${_portage_diffs}" || { echo "Couldn't create \"${_portage_diffs}\" directory" >&2 ; exit 1 ; }
cd "${_portage_diffs}" || { echo "Couldn't enter \"${_portage_diffs}\"" >&2 ; exit 1 ; }
if [[ $1 == -c || $1 == --clean ]] ; then
	if [[ "$KEEP2" && -d latest ]] ; then
		[[ -f latest/datetimestamp ]] || { echo "Can't find datetimestamp file in latest backup." >&2 ; exit 1 ; }
		[[ -d "$(< latest/datetimestamp)" ]] && { echo "Can't rename 'latest' to '$(< latest/datetimestamp)' because already exists." >&2 ; exit 1 ; }
		echo "NOTE: renaming 'latest' directory to '$(< latest/datetimestamp)'"
		mv latest "$(< latest/datetimestamp)"
	fi
	dirs=( $( ls | sort ) )
	declare -i nd
	nd=${#dirs[*]}
	if [[ "$KEEP2" && (( nd < 3 )) ]] ; then
		dirs=( )
		nd=0
	elif [[ "$KEEP2" ]] ; then
		unset dirs[$(( --nd ))]
		unset dirs[$(( --nd ))]
	fi
	if (( $nd > 0 )) ; then
		echo '!!! CLEAN: About to remove the following gendiff dirs:'
		for dir in "${dirs[@]}" ; do echo $dir; done
		sleep 3
		for dir in "${dirs[@]}" ; do
			echo "removing \"${dir}\""
			rm -rf "${dir}" || { echo "Couldn't remove directory \"${dir}\"" >&2 ; exit 1 ; }
		done
	else
		echo "Nothing to clean!" >&2
	fi
else
	if [[ -d ${gendiffs_outdir} ]] ; then
		[[ -f latest/datetimestamp ]] || { echo "Can't find datetimestamp file in latest backup." >&2 ; exit 1 ; }
		[[ -d "$(< latest/datetimestamp)" ]] && { echo "Can't rename 'latest' to '$(< latest/datetimestamp)' because already exists." >&2 ; exit 1 ; }
		echo "NOTE: renaming 'latest' directory to '$(< latest/datetimestamp)'"
		mv latest "$(< latest/datetimestamp)"
	fi
fi

echo "Creating \"${gendiffs_outdir}\""

mkdir -p ${gendiffs_outdir} || { echo "Couldn't create \"${gendiffs_outdir}\"" >&2 ;  exit 1 ; }
echo "${gendiffs_datetime}" > "${gendiffs_outdir}/datetimestamp" || { echo "WTF???" >&2 ; exit 1 ; }

echo '** processing overlay directories **'

dirs=( )
while read dir ; do
	dirs[${#dirs[*]}]="${dir}"
done < <( cd ${_overlay} ; find . -maxdepth 2 \( -name '.git' -prune \) -o \( -type d -regextype posix-extended \
	  -regex '\./([[:alnum:]_]*-[[:alnum:]_]*/[^/]*|eclass)' -print \) | \
	  sed 's/^..//' )

my_file() {
	local old_pwd="$(pwd)"
	cd "$gendiffs_eprefix" || { echo "Couldn't cd to \"${gendiffs_eprefix}\"" >&2 ; exit 1 ; }
	local the_file="${1}"
	shift
	[[ "$the_file" ]] || { echo "my_file called with no file!" >&2 ; return 1 ; }
	declare -a args
	[[ -e "${gendiffs_portage_tree}/${the_file}" || -h "${gendiffs_portage_tree}/${the_file}" ]] && \
		args[${#args[*]}]="${gendiffs_portage_tree}/${the_file}"
	[[ -e "${gendiffs_overlay}/${the_file}" || -h "${gendiffs_overlay}/${the_file}" ]] && \
		args[${#args[*]}]="${gendiffs_overlay}/${the_file}"
	[[ ${#args[*]} == 0 ]] && {
		echo "my_file called for \"${the_file}\" but no file found: pwd=\"$(pwd)\";" \
		     "files tested: \"${gendiffs_portage_tree}/${the_file}\", \"${gendiffs_overlay}/${the_file}\"!" >&2
		return 1
	}
	local arg
	file "${args[@]}" "$@"
	cd "$old_pwd" || { echo "Couldn't cd to \"${old_pwd}\"" >&2 ; exit 1 ; }
}

declare -a fl
declare -a fl_dir

# adds its argument to the given array (which is presumed to be sorted)
# in a sorted manner.  my god, is there some way to speed this up!?
sort_add() {
	local doadd=yes
	local the_array="${1}"
	local add="${2}"
	declare -i max
	eval "max=\${#${the_array}[*]}"
	local found=no
	declare -i i
	i=0
	local dummy
	while (( $i < max )) ; do
		local compareme
		eval "compareme=\${${the_array}[${i}]}"
		if [[ "${compareme}" == "${add}" ]] ; then
			# its already there so nothing to do
			return 0
		elif [[ "${compareme}" > "${add}" ]] ; then
			# we found where it goes but first we need to make room for it
			found="${i}"
			break
		fi
		dummy=$(( i++ ))
	done
	# found is poorly named -- it means we found /where/ to put it
	# but not the thing itself.  so if we got here and found is false,
	# we need to put it at the end
	if [[ ${found} == no ]] ; then
		eval "${the_array}[${max}]=\"${add}\""
		# otherwise we added it when we found it.
	else
		# make room for the new item
		i=${max}
		while (( $i > $found )) ; do
			# note: apparently in cases like this bash evaluates the
			# rvalue /before/ the lvalue... how counter-intuitive!
			eval "${the_array}[\$((i--))]=\"\${${the_array}[\$((i - 1))]}\""
		done
		eval "${the_array}[${found}]=\"${add}\""
	fi
}

only_in_overlay() {
	local the_file="$1"
	only_in_overlay_output=`if [[ "$only_in_overlay_output" ]] ; then echo "$only_in_overlay_output"; fi; my_file "${the_file}"`
	if [[ -h "${_overlay}/${file}" && ( ! -e "${_overlay}/${file}" ) ]] ; then
		echo "WARNING: dangling overlay-only symbolic link: \"${the_file}\" -> \"$(readlink "${_overlay}/${file}")\"" | \
			tee -a "${gendiffs_outfile}"
	elif echo "${the_file}" | grep '\.exe\.stackdump$|\/core$' > /dev/null ; then
		echo "WARNING: probable core-dump: \"${the_file}\"" | tee -a "${gendiffs_outfile}"
	fi
	return 0
}

only_in_portage() {
	local the_file="$1"
	only_in_portage_output=`if [[ "$only_in_portage_output" ]] ; then echo "$only_in_portage_output"; fi; my_file "${the_file}"`
	return 0
}

raw_files_equal() {
	local file1="${1}"
	local file2="${2}"
	if [[ "$(< "${file1}" )" == "$(< "${file2}" )" ]] ; then
		return 0
	else
		return 1
	fi
}

is_probably_binary() {
	local file="${1}"
	file -bi "$file" | egrep "charset=binary$" && {
		echo "yes"
		return 0
	}
	echo "no"
	return 1
}

compare_regular_file() {
	local file="${1}"
	# ignore Manifest files
	echo "$file" | egrep "^[^-/]*-[^-/]*\/[^/]*\/Manifest$" > /dev/null && return 0
	# ignore vim .swp files.
	[[ $file == *.swp ]] && return 0
	# ignore cygwin coredumpish thingys
	[[ $file == *.exe.stackdump ]] && return 0
	# if the files have the exact same contents then we just do nothing
	raw_files_equal "${_overlay}/${file}" "${_portage}/${file}" && return 0
	# the files differ.
	local ovl_is_binary="$( is_probably_binary "${_overlay}/${file}" )"
	local prt_is_binary="$( is_probably_binary "${_portage}/${file}" )"
	if [[ "${ovl_is_binary}" != "${prt_is_binary}" ]] ; then
		echo "WARNING: ${file}: file type mismatch (binary/non-binary):" | tee -a "${gendiffs_outfile}"
		my_file "${file}" | tee -a "${gendiffs_outfile}"
		return 0
	elif [[ "${ovl_is_binary}" == "yes" ]] ; then
		echo "Binary files differ: \"${file}\"" >> "${gendiffs_outfile}"
	else
		# we have two non-binary files that differ -- time to diff them
		# but first ... are they patch files?
		if echo "$file" | egrep "\.(patch|diff)$" > /dev/null ; then
			echo "WARNING: ${file}: differing patch files considered harmful!" | tee -a "${gendiffs_outfile}"
		fi
		echo "----(\"${file}\")----->8----->" >> "${gendiffs_outfile}"
		(
			cd "$gendiffs_eprefix" || { echo "Couldn't cd to \"${gendiffs_eprefix}\"" >&2 ; exit 1 ; }
			local diffresult="$( diff -U 3 -w -B \
				"${gendiffs_portage_tree}/${file}" \
				"${gendiffs_overlay}/${file}" )"
			if (( $( echo "${diffresult}" | wc -l ) < 5 )) ; then
				echo '!!!!! WARNING: pathological diffresult !!!!!' | tee -a "${gendiffs_outfile}" >&2
				echo "pathological diffresult was:" >&2
				echo "${diffresult}" >&2
			fi
			local header1="$( echo "${diffresult}" | head -n 1 | sed -e 's/[[:space:]]*[[:digit:]-]\{10\} [[:digit:].:]\{18\} -[[:digit:]]\{4\}$//') [[PORTAGE]]"
			local header2="$( echo "${diffresult}" | head -n 2 | tail -n 1 | sed -e 's/[[:space:]]*[[:digit:]-]\{10\} [[:digit:].:]\{18\} -[[:digit:]]\{4\}$//') [[OVERLAY]]"
			local body="$( echo "${diffresult}" | tail -n +3 )"
			echo "${header1}"
			echo "${header2}"
			echo "${body}"
		) >> "${gendiffs_outfile}"
		echo "<-----8<-----" >> "${gendiffs_outfile}"
	fi
	return 0
}

compare_file() {
	local file="${1}"
	# fl and fl_dir are global so we cannot recurse while using them.
	fl=( )
	fl_dir=( )
	if [[ ( ! -h "${_portage}/${file}" ) && ( ! -e "${_portage}/${file}" ) ]] ; then
		only_in_overlay "${file}"
	elif [[ ( ! -h "${_overlay}/${file}" ) && ( ! -e "${_overlay}/${file}" ) ]] ; then
		only_in_portage "${file}"
	elif [[ \
		( -h "${_portage}/${file}" && ! -h "${_overlay}/${file}" ) || \
	        ( -h "${_overlay}/${file}" && ! -h "${_portage}/${file}" ) || \
		( -d "${_portage}/${file}" && ! -d "${_overlay}/${file}" ) || \
	        ( -d "${_overlay}/${file}" && ! -d "${_portage}/${file}" ) || \
		( -f "${_portage}/${file}" && ! -f "${_overlay}/${file}" ) || \
	        ( -f "${_overlay}/${file}" && ! -f "${_portage}/${file}" ) \
	]] ; then
		echo "WARNING: ${file}: file type mismatch:" | tee -a "${gendiffs_outfile}"
		my_file "${file}" | tee -a "${gendiffs_outfile}"
	elif [[ -h "${_overlay}/${file}" ]] ; then
		local ovllink="$(readlink "${_overlay}/${file}" )"
		local prtlink="$(readlink "${_portage}/${file}" )"
		if [[ "${ovllink}" != "${prtlink}" ]] ; then
			echo "mutual symbolic links differ at \"${file}\":" >> "${gendiffs_outfile}"
			echo "portage links to: \"${prtlink}\"." >> "${gendiffs_outfile}"
			echo "overlay links to: \"${ovllink}\"." >> "${gendiffs_outfile}"
		fi
	elif [[ -d "${_overlay}/${file}" ]] ; then
		echo "===== mutual sub-directory: \"${file}\" =====" >> "${gendiffs_outfile}"
		declare -a check_subs
		local sub
		while read sub; do
			# if the file we are adding is a directory in both portage and in
			# the overlay, then we add it to the fl_dir array instead of fl, and
			# we consider these last when we recurse.  The reason for this is so
			# that in the output file, all diffs and informational messages will
			# appear under the heading ("===== blah =====") to which they directly
			# pertain (a cosmetic concern but one which adds considerably to clarity,
			# as once we recurse, additional headings will be displayed, misleading
			# the user as to where they "are" in the tree
			if [[ -d "${_portage}/${file}/${sub}" && -d "${_overlay}/${file}/${sub}" ]] ; then
				sort_add "fl_dir" "${sub}"
			else
				sort_add "fl" "${sub}"
			fi
		done < <( cd "${_overlay}/${file}" && ls -a | grep -v '^\.*$' && \
		          cd "${_portage}/${file}" && ls -a | grep -v '^\.*$' )
		check_subs=( "${fl[@]}" "${fl_dir[@]}" )
		for sub in "${check_subs[@]}"; do
			compare_file "${file}/${sub}"
		done
	elif [[ -f "${_overlay}/${file}" ]] ; then
		# Here we have two regular files that we need to compare.
		# This is the real meat of the whole gendiffs program so
		# lets break this out into a subfunction.
		compare_regular_file "${file}"
	else
		echo "WARNING: I have no idea what to do with these (\"${file}\"):" | tee -a "${gendiffs_outfile}"
		my_file "${file}" | tee -a "${gendiffs_outfile}"
	fi
}

for dir in "${dirs[@]}"; do
	gendiffs_outfile="${gendiffs_outdir}/${dir//\//_}"
	only_in_overlay_output=""
	only_in_portage_output=""
	echo "${dir}"
	compare_file "${dir}"
	if [[ "$only_in_overlay_output" ]] ; then
		echo >> "${gendiffs_outfile}"
		echo "*** The following files appear only in the overlay ***" >> "${gendiffs_outfile}"
		echo "${only_in_overlay_output}" >> "${gendiffs_outfile}"
		[[ "$only_in_portage_output" ]] || echo >> "${gendiffs_outfile}"
	fi
	if [[ "$only_in_portage_output" ]] ; then
		echo >> "${gendiffs_outfile}"
		echo "*** The following files appear only in portage ***" >> "${gendiffs_outfile}"
		echo "${only_in_portage_output}" >> "${gendiffs_outfile}"
		echo >> "${gendiffs_outfile}"
	fi
done

echo "Done."
exit 0
