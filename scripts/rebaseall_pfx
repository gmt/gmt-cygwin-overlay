#!/bin/ash

# Copyright (c) 2003, 2005, 2006, 2008, 2011, 2012 Jason Tishler
#               2012 Greg Turner
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# See the COPYING file for full license information.
#
# Written by Jason Tishler <jason@tishler.net>
# cygwin-prefix support by Greg Turner <gmturner007@ameritech.net>

# Somehow a lot of /cygdrive/c/cygwin/foo paths end up floating around in Cygwin's brain
# despite more efficient /foo representations.  It couldn't hurt to keep them out of PWD
# and PATH.
cd /bin
PATH=/bin

# Define constants
tp1=${0%/*}
tp2=${tp1:-.}
ProgramName=${0##*/}
ProgramOptions='o:ps:P:tT:D:v'
# by leaving this gap, we leave room for ASLR to work its magic
DefaultBaseAddress=0x70000000
PrefixBaseAddress=0x79000000
DefaultNoDyn=
DefaultOffset=0
DefaultTouch=
DefaultVerbose=
DefaultFileList=
DefaultSuffixes='dll|so|oct'
ExtraDirList=
db_file="/etc/rebase.db.i386"
Mach="-4"

# Define functions
usage()
{
    echo "usage: ${ProgramName} [-P EPrefix] [-o Offset] [-s DllSuffix] [-T FileList | -]"
    echo "                      [-D ExtraDirList] [-p] [-t] [-v]"
    echo
    echo '  Separate "ExtraDirList" options with colons like in a ${PATH}'
    echo '  Either use the -P argument or export the EPREFIX environment variable'
    echo
    exit 1
}

cleanup()
{
    rm -f "${TmpFile}"
    rm -f "${TmpFile}_prefix"
    rm -f "${TmpFile}_non-prefix"
    rm -f "${TmpFile}_dirlist"
    rm -f "${TmpFile}_extra_dirlist"
    rm -f "${TmpFile}_filelist"
    rm -f "${TmpFile}_perl"
    # rm -f "${TmpFile}_python"
    # rm -f "${TmpFile}_etc_setup_perlpython"
    rm -f "${TmpFile}_etc_setup_perl"
    rm -f "${TmpFile}_etc_setup_all"
    rm -f "${TmpFile}_etc_setup"
    exit ${ExitCode}
}

# Set traps
trap cleanup 1 2 15

# Set defaults
BaseAddress=""
Offset="${DefaultOffset}"
Touch="${DefaultTouch}"
NoDyn="${DefaultNoDyn}"
Verbose="${DefaultVerbose}"
FileList="${DefaultFileList}"
Suffixes="${DefaultSuffixes}"
if [ -n "${EPREFIX}" ] ; then
  EPrefix="${EPREFIX}"
else
  EPrefix=
fi
force_dash_only="no"
# db_file_x86_64="/etc/rebase.db.x86_64"

# Determine platform
Platform=`uname -s`
case $Platform in
 *CYGWIN* | *cygwin* ) Platform=cygwin ;;
 * )
    echo "Unsupported platform: $Platform" 1>&2
    exit 1
    ;;
esac

# Parse command line arguments
while getopts "${ProgramOptions}" Option "$@"
do
    case "${Option}" in
    o)
	Offset="${OPTARG}";;
    p)
	force_dash_only="yes";;
    P)
        EPrefix="${OPTARG}";;
    s)
	Suffixes="${Suffixes}|${OPTARG}";;
    t)
	Touch="-t";;
    T)
	FileList="${OPTARG}";;
    D)
    	ExtraDirList="${OPTARG}";;
    v)
	Verbose="-v";;
    \?)
	usage;;
    esac
done

PATH=$EPrefix/bin:$EPrefix/usr/bin:$EPrefix/sbin:$EPrefix/usr/sbin:/bin

# Verify only ash or dash processes are running
ProcessResult=0
stopthese=$(grep -E -i -v '/(d?ash(.exe)?|grep(.exe)?)$' /proc/[0-9]*/exename)
ProcessResult=$?

if [ $ProcessResult -eq 0 -a -z "${RebaseDebug}" ]
then
  if [ $force_dash_only = yes ]
  then
    echo "${ProgramName}: ERROR: only ash or dash processes are allowed during rebasing"
  else
    echo "${ProgramName}: WARNING: non-ash, non-dash processes present during rebasing"
  fi
  echo "    Exit all Cygwin processes and stop all Cygwin services."
  echo "    Execute ash (or dash) from Start/Run... or a cmd or command window."
  echo "    Execute the rebaseall_pfx script from ash (or dash)."
  echo
  echo "The following processes should be stopped:"
  echo "${stopthese}" | sed 's|/proc/\([0-9]*\)/exename:\(.*\)$|\2 (PID: \1)|'
  echo
  if [ $force_dash_only = yes ]
  then
    exit 2
  fi
fi

BaseAddress=$DefaultBaseAddress

# Set temp directory
TmpDir="${TMP:-${TEMP:-/tmp}}"

# Validate temp directory
if [ ! -d "$TmpDir" ]
then
    echo "$ProgramName: '$TmpDir' is not a directory"
    exit 2
fi
if [ ! -w "$TmpDir" ]
then
    echo "$ProgramName: '$TmpDir' is not writable"
    exit 2
fi

# Validate user supplied file list, if necessary
if [ -n "$FileList" -a ! -r "$FileList" -a "$FileList" != - ]
then
    echo "$ProgramName: '$FileList' is not readable"
    exit 2
fi

# Validate EPrefix
if [ -z "$EPrefix" ] ; then
    echo "$ProgramName: either set EPREFIX enviornment variable or supply -P argument"
    exit 2
fi

case "${EPrefix}" in
    /*)
        :; # noop
	;;
    *) 
        echo "$ProgramName: EPREFIX must start with '/'"
        exit 2
        ;;
esac

dirlist=

check_dirs()
{
    nupath=
    for d in "$@" ; do
        if [ ! -d "$d" ] ; then
            echo "$ProgramName: '$d' is not a directory (ignored)"
            continue
        fi
	if [ x${dirlist} = x ] ; then
	    dirlist="${d}"
        else
            dirlist="${dirlist}:${d}"
        fi
    done
}

check_dirs "${EPrefix}/bin" "${EPrefix}/usr/bin" "${EPrefix}/sbin" "${EPrefix}/usr/sbin" \
		"${EPrefix}"/usr/i686-pc-cygwin1.7/binutils-bin/* \
		"${EPrefix}"/usr/i686-pc-cygwin1.7/gcc-bin/*

PATH="${dirlist}:${PATH}"
export PATH

# Validate ExtraDirList
if [ -n "$ExtraDirList" ]
then
    echo "${ExtraDirList}" | sed 's/:/\n/g' | while read d ; do
        if [ ! -d "${d}" ] ; then
		echo "$ProgramName: '$d' is not a directory"
		exit 7
	fi
    done
    # lol /bin/sh
    if [ $? -eq 7 ] ; then
	    exit 2
    fi
fi

# Set temp file
TmpFile="$TmpDir/rebase.lst"

# filter for suffixes, then remove perl (formerly: and python) library
# directories, cygwin1.dll, lsa-dll, dash/ash, mingw sysroot,
# and the dolib.so/newlib.so files, which are actually scripts.
filter_cygwin_targets()
{
  local filter_perlpython
  # filter_perlpython="$1"
  # filter_perlpython="${filter_perlpython:-yes}"
  filter_perl="$1"
  filter_perl="${filter_perl:-yes}"
  grep -E "\.($Suffixes)\$" | \
    if [ ${filter_perl} = no ] # was: filter_perlpython
    then
      tee /dev/null
    else
      # grep -E -v -e '(/(cygperl|libpython)[[:digit:].-_]*\.dll$|/lib/(perl|python)[[:digit:].-_]*/)'
      grep -E -v -e '(/cygperl[[:digit:].-_]*\.dll$|/lib/perl[[:digit:].-_]*/)'
    fi | \
    sed -e '/cygwin1\.dll$/d' \
      -e '/cyglsa.*\.dll$/d' \
      -e '/d?ash\.exe$/d' \
      -e '/rebase\.exe$/d' \
      -e '/sys-root\/mingw/d' \
      -e '/ebuild-helpers\/dolib.so$/d' \
      -e '/ebuild-helpers\/newlib.so$/d'
}

# select_perlpython_targets ()
select_perl_targets ()
{
  # grep -E -e '(/(cygperl|libpython)[[:digit:].-_]*\.dll$|/lib/(perl|python)[[:digit:].-_]*/)'
  grep -E -e '(/cygperl[[:digit:].-_]*\.dll$|/lib/perl[[:digit:].-_]*/)'
}

if [ -n "${FileList}" ]
then
  if [ -f "${FileList}" ]
  then
    echo "Scanning user-provided files in \"${FileList}\" ..." >&2
    cat "${FileList}"
  else
    echo "WARNING: FileList \"${FileList}\" provided but not found." >&2
  fi
fi | filter_cygwin_targets > "${TmpFile}_filelist"
if [ -n "${ExtraDirList}" ]
then
  echo "${ExtraDirList}" | sed 's/:/\n/g' | while read d
  do
    echo "Scanning \"${d}\" (extra) ..." >&2
    find "${d}" -type f
  done
fi | filter_cygwin_targets > "${TmpFile}_extra_dirlist"
if [ -n "${dirlist}" ]
then
  echo "${dirlist}" | sed 's/:/\n/g' | while read d
  do
    echo "Scanning \"${d}\ (built-in) ..." >&2
    find "${d}" -type f
  done
fi | filter_cygwin_targets > "${TmpFile}_dirlist"
first_lstgz=1
for lstgz in /etc/setup/*.lst.gz
do
  [ -f "${lstgz}" ] || continue
  if [ $first_lstgz -eq 1 ]
  then
    first_lstgz=0
    echo -n 'Scanning /etc/setup/*.lst.gz: ' >&2
  fi
  lstgzbase="${lstgz##*/}"
  if [ x${Verbose} = x-v ]
  then
    echo -n "${lstgzbase%.lst.gz} " >&2
  else
    echo -n "." >&2
  fi
  gzip -d -c "${lstgz}" | sed -e 's/^/\//'
done | filter_cygwin_targets no > "${TmpFile}_etc_setup_all" # perl (and formerly python) allowed

if [ $first_lstgz -eq 1 ]
then
  echo >&2
fi

# imo we don't particularly want perl (and formerly, python) targets in the database since
#   o Multiple versions with identical basenames can exist and this would
#     mess up the merging process
#   o Installing them will fuck up oblivious mode for future perl (and formerly python) users
# Non prefix cygwin's rebase will put them in there anyhow, but it's
# no big deal, the difference is pretty subtle/negligible.

# echo "Cherry-picking non-prefix perl & python targets..." >&2
echo "Cherry-picking non-prefix perl targets..." >&2
cat "${TmpFile}_etc_setup_all" | filter_cygwin_targets > "${TmpFile}_etc_setup"
# cat "${TmpFile}_etc_setup_all" | select_perlpython_targets > "${TmpFile}_etc_setup_perlpython"
cat "${TmpFile}_etc_setup_all" | select_perl_targets > "${TmpFile}_etc_setup_perl"

# Merge the lists, prioritizing first, FileList; second, ExtraDirList;
# third, dirlist; and fourth, /etc/setup.  Discard non-prioritized duplicate
# filenames with a friendly warning.
echo "Merging lists ..." >&2
merged_basenames=
cat "${TmpFile}_filelist" "${TmpFile}_extra_dirlist" "${TmpFile}_dirlist" "${TmpFile}_etc_setup" | \
  while read filepath ; do
    case $filepath in
      */) echo "WARNING: filepath ending in '/': \"${filepath}\"" >&2 ; continue;;
    esac
    filepath_basename="${filepath##*/}"
    filepath_pathname="${filepath%/*}"
    case "${merged_basenames}" in
      *"|${filepath_basename}=/"*)
        already_have="$(
          echo "${merged_basenames}" 2>/dev/null | sed -e 's/|/\n/g' 2>/dev/null | grep -v '^[[:space:]]*$' 2>/dev/null | \
            while read haveline
            do
              havebasename="${haveline%=*}"
              case x${havebasename}x in
                x${filepath_basename}x)
                  havepathname="${haveline##*=}"
                  echo "${havepathname}/${havebasename}"
                  break
                  ;;
              esac
            done
        )"
        case x"${already_have}"x in
          x"${filepath}"x)
            :; # don't warn: not at all interesting.
            ;;
          *)
            # we can still skip the warning if the files are the same
            fi=$( ls -i "${filepath}" | sed 's/ .*//' )
            ai=$( ls -i "${already_have}" | sed 's/ .*//' )
            if [ ${fi} -ne ${ai} ]
            then
              echo -n "duplicate: ${filepath}" >&2
              if [ x${Verbose} = x-v ]
              then
                echo " (already had ${already_have})" >&2
              else
                echo >&2
              fi
            fi
            ;;
        esac
        ;;
      *)
        echo "${filepath}"
        merged_basenames="|${filepath_basename}=${filepath_pathname}|${merged_basenames}"
        ;;
    esac
  done > "${TmpFile}"
  
# Unconditionally add the -n flag so rebased DLLs get the dynamicbase flag removed.
NoDyn='-n'

echo "Separating prefix and non-prefix files..." >&2
# split out the prefix and non-prefix stuff from ${TmpFile}
cat "${TmpFile}" | grep -v '^'"${EPrefix}" > "${TmpFile}_non-prefix"
cat "${TmpFile}" | grep '^'"${EPrefix}" > "${TmpFile}_prefix"

# That was the easy part; now it gets complicated :)

filter_rebase_failures()
{
  local TempFile="$1"
  shift
  rebase "${Touch}" "${NoDyn}" "${Mach}" -o "${Offset}" "$@" -T "${TempFile}" 2>"${TempFile}_err"
  errorfiles="$( echo $(
    cat "${TempFile}_err" | {
      gotinuseline=0
      while read line
      do
        echo "${line}" >&2
	if echo "${line}" | grep -E -q ': skipped because (could not open|nonexistent\.)$'
	then
	  echo ":${line%:*}:"
	elif echo "${line}" | grep -E -q '^ReBaseImage \(.*\) failed'
	then
	  line2="${line#ReBaseImage (}"
	  echo ":${line2%%)*}:"
        elif [ ${gotinuseline} -eq 1 ]
	then
	  echo ":${line}:"
	elif echo "${line}" | grep -E -q '^The following DLLs couldn.t be rebased because they were in use:$'
	then
	  gotinuseline=1
        fi
      done
    }
  ) )"
  rm "${TempFile}_err"
# if [ x${Verbose} = x-v ]
# then
#   echo "DEBUG: errorfiles=\"${errorfiles}\"" >&2
# fi
  mv "${TempFile}" "${TempFile}_raw"
  # note: if rebase decides to dump something other than the original filename to stdout, we
  # may need to beef this up (i.e., by comparing inode numbers).  So far, this seems to do it.
  cat "${TempFile}_raw" | grep -v "^[[:space:]]*$" | while read f
  do
    case "${errorfiles}" in
      *":${f}:"*) :; ;; # noop
      *) echo "${f}" ;;
    esac
  done > "${TempFile}"
  rm "${TempFile}_raw"
}

# echo "Rebasing non-prefix, non-perl, non-python files..." >&2
echo "Rebasing non-prefix, non-perl files..." >&2
if [ -e ${db_file} ]
then
  PATH=/bin filter_rebase_failures "${TmpFile}_non-prefix" -s
else
  PATH=/bin filter_rebase_failures "${TmpFile}_non-prefix" -b "${BaseAddress}"
fi

# echo "Rebasing non-prefix perl and python files (in oblivious mode)..." >&2
echo "Rebasing non-prefix perl files (in oblivious mode)..." >&2
filter_rebase_failures "${TmpFile}_etc_setup_perl" -O

BaseAddress="${PrefixBaseAddress}"

# now rebase the prefix stuff. ignore the database and place everything above the $BaseAddress
# cutoff, to minimize conflicts with the non-prefix cygwin rebasing system.
echo "Rebasing prefix cygwin files..." >&2
filter_rebase_failures "${TmpFile}_prefix" -b "${BaseAddress}"

BASE_prefix="${PrefixBaseAddress}"
basevars="BASE_prefix"

# determine_new_base will parse the output of rebase -i and find the
# highest address used.  It will then add an optional fudge factor,
# which is a small integer constant to be multiplied by the difference
# between the BaseAddress (or 3rd argument, if provided) and the
# highest address found (set fudgefactor to zero to pack everything in tight).
# Finally, it will store that fudge-factor-added base address into the
# BASE_foo variable, where "foo" is the first argument ("basename").
#
# The idea is to create a "stack" of bases, growing upward, that we can
# manually maintain in order to avoid unneccesary rebasing during ebuilds.
#
# There is an additional complication: if BASE_foo is already set to a
# number larger than the address calculated based on rebase -i and the
# fudge factor, then BASE_foo will not be changed.  This allows
# multiple parallel implementations to coexist in the same "slot", so
# to speak.  Later, we may wish to extend this to effectively create
# our own extended database.  For now, we just use it to keep parallel
# implementations of perl (and formerly python) from gobbling up huge
# amounts of address space.
#
# This is more of a concern for cygwin prefix because somebody might
# keep emerging the same thing over and over.  If we just keep growing
# the address space every time, eventually we'll run out.
#
# It does present a problem if, i.e., perl "A" attempts to invoke perl "B".
# in that case, because we deliberately allowed them to overlap, we
# are going to see a real train-wreck.  If this is seen happening in
# the wild, we may wish to change our approach to putting everything 
# in a separate address-space slot.

determine_new_base()
{
  local xbasename xbasefile oldbase fudgefactor bs base size newbase newbaseoffset newbasepad oldBASE newBASE realnewBASE baseincr
  xbasename="$1"
  xbasefile="$2"
  oldbase="$3"
  oldbase="${oldbase:-${BaseAddress}}"
  fudgefactor="$4"
  fudgefactor="${fudgefactor:-1}"
  echo -n "Determining new effective maximum base address (${xbasename}): " >&2
# if [ x${Verbose} = x-v ]
# then
#   echo "<DEBUG>" >&2
#   rebase "${Verbose}" "${Mach}" -i -T "${xbasefile}" >&2
#   echo -n "</DEBUG>: " >&2
# fi
  bs="$( rebase "${Mach}" -i -T "${xbasefile}" | tail -n 1 )"
  bs="$( echo "$bs" | \
    sed 's/^.*base \([0-9a-fx]*\)[[:space:]]*size \([0-9a-fx]*\)[[:space:]]*$/\1 \2/' )"
  base="${bs% *}"
  size="${bs#* }"
  if [ x${Verbose} = x-v ]]
  then
    echo -n "(top:base=${base};size=${size}) " >&2
  fi
  newbase=$(( base + size ))
  newbaseoffset=$(( newbase - oldbase ))
  newbasepad=$(( newbase + newbaseoffset * fudgefactor ))
  if [ $(( newbasepad )) -gt $(( 0xffffffff )) ]
  then
    echo "ERROR: 32-bit arithmetic overflow, use less fudge" >&2
    exit 2
  fi
  newBASE="$( printf "0x%08x\n" $newbasepad )"
  oldBASE="$( eval "echo \$BASE_${xbasename}" )"
  oldBASE="${oldBASE:-0x00000000}"
  realnewBASE="$( printf "0x%08x\n" "$(( oldBASE ))" )"
  if [ $(( newBASE )) -gt $(( oldBASE )) ]
  then
    realnewBASE="${newBASE}"
  fi
  # crude round up to nearest x s.t. x mod 0x1000(4KiB) = 0
  if [ ${realnewBASE%???}000 != ${realnewBASE} ]
  then
    baseincr=$(( ${realnewBASE%???} + 1 ))
    realnewBASE="$( printf "0x%05x\n" "$(( baseincr ))" )000"
  fi
  eval "BASE_${xbasename}=\"${realnewBASE}\""
  case "$basevars" in
    *"BASE_${xbasename}"*) :; ;;
    *) basevars="BASE_${xbasename}${basevars:+ }${basevars}" ;;
  esac
  echo "${realnewBASE}" >&2
}

force_reasonable_base()
{
  local oldbasename newbasename oldBASE newBASE
  oldbasename="$1"
  newbasename="$2"
  oldBASE="$( printf "0x%08x\n" $( eval "echo \$BASE_${oldbasename}" ) )"
  oldBASE="${oldBASE:-0x80000000}"
  newBASE="$( printf "0x%08x\n" $( eval "echo \$BASE_${newbasename}" ) )"
  newBASE="${newBASE:-0x00000000}"
  if [ $(( newBASE )) -lt $(( oldBASE )) ]
  then
    newBASEaddr=
    newBASE="$( printf "0x%08x\n" "$(( oldBASE + 0x0A000000 ))" )"
    echo "Forcing reasonable BASE_${newbasename}: ${newBASE}" >&2
  fi
  eval "BASE_${newbasename}=\"${newBASE}\""
  case "$basevars" in
    *"BASE_${newbasename}"*) :; ;;
    *) basevars="BASE_${newbasename}${basevars:+ }${basevars}" ;;
  esac
}

dump_basevars()
{
  local basevar
  for basevar in $basevars
  do
    varval="$( eval "echo \$${basevar}" )"
    echo "${basevar}=\"${varval}\""
  done
}

determine_new_base perl "${TmpFile}_prefix"
# in case of disaster (i.e., triggered by empty prefix)
force_reasonable_base prefix perl

BaseAddress="${BASE_perl}"

echo "Scanning prefix perl directories..." >&2
# perl
perldirs="$(
  for libdir in share lib lib32 lib64
  do
    d="${EPrefix}/usr/${libdir}/perl5"
    [ -d "${d}" ] && \
      find "${d}" -maxdepth 3 -type d -name 'i686-cygwin*' | \
      while read d2
      do
        [ $( find "${d2}" -type f | filter_cygwin_targets no | wc -l ) -gt 0 ] && echo ${d2}
      done
  done
)"

echo "Mapping perl directories to perl versions..." >&2
perlspecmaps=
for d in $perldirs
do
  p_basename="${d##*/}"
  p_pathname="${d%/*}"
  p_version="${p_pathname##*/}"
  p_spec="${p_version}-${p_basename}"
  newperlspecmaps=
  foundspec=0
  OIFS="${IFS}"
  IFS=";"
  for perlspecmap in ${perlspecmaps}
  do
    perlspecmapspec="${perlspecmap%%|*}"
    perlspecmapdirs="${perlspecmap#*|}"
    case x${perlspecmapspec}x in
      x${p_spec}x)
        foundspec=1
        newperlspecmaps="${newperlspecmaps}${newperlspecmaps:+;}${p_spec}|${perlspecmapdirs}:${d}"
	;;
      *)
        newperlspecmaps="${newperlspecmaps}${newperlspecmaps:+;}${perlspecmap}"
	;;
    esac
  done
  IFS="${OIFS}"
  if [ $foundspec -eq 0 ]
  then
    newperlspecmaps="${newperlspecmaps}${newperlspecmaps:+;}${p_spec}|${d}"
  fi
  perlspecmaps="${newperlspecmaps}"
done

if [ x${Verbose} = x-v ]
then
  echo "perlspecmaps: \"${perlspecmaps}\"" >&2
fi

OIFS="${IFS}"
IFS=";"
for perlspecmap in $perlspecmaps
do
  perlspec="${perlspecmap%%|*}"
  perlspecdirs="${perlspecmap#*|}"
  IFS=":"
  if [ x${Verbose} = x-v ]
  then
    for perlspecdir in ${perlspecdirs}
    do
      echo "  Processing directory: \"${perlspecdir}\"" >&2
    done
  fi
  find ${perlspecdirs} -type f | filter_cygwin_targets no > "${TmpFile}_perl"
  IFS=";"
  cygperl="${EPrefix}/usr/bin/cygperl$( echo "${perlspec%%-*}" | sed 's/\./_/g' ).dll"
  if [ -f "${cygperl}" ]
  then
    echo "${cygperl}" >> "${TmpFile}_perl"
  else
    if [ x${Verbose} = x-v ]
    then
      echo "INFO: \"${cygperl}\" for perlspec \"${perlspec}\" not found." >&2
    fi
  fi
  if [ $( cat "${TmpFile}_perl" | wc -l ) -gt 0 ]
  then
    echo "Rebasing perl files for version: \"${perlspec}\"..." >&2
    filter_rebase_failures "${TmpFile}_perl" -b "${BaseAddress}"
#   determine_new_base python "${TmpFile}_perl" "${BaseAddress}" 3
    determine_new_base ebuild "${TmpFile}_perl" "${BaseAddress}" 3
  fi
done
IFS="${OIFS}"

# force_reasonable_base perl python
force_reasonable_base perl ebuild
# BaseAddress="${BASE_python}"
#
# for d in "${EPrefix}"/usr/lib/python* ; do
#   if [ -d "${d}" ]
#   then
#     if [ $( echo "${d}/foo/bar.dll" | select_perlpython_targets | wc -l ) -eq 1 ]
#     then
#       echo "Scanning python directory: \"${d}\"..." >&2
#       find ${d} -type f | filter_cygwin_targets no > "${TmpFile}_python"
#       pythonver="$( echo "${d}" | sed 's/^.*python\([[:digit:].-_]*\)$/\1/' )"
#       pythondll="${EPrefix}/usr/bin/libpython${pythonver}.dll"
#       if [ -f "${pythondll}" ]
#       then
#         echo "${pythondll}" >> "${TmpFile}_python"
#       else
#         echo "WARNING: Expected version \"${pythonver}\" python dll to be \"${pythondll}\" but not found." >&2
#       fi
#       if [ $( cat "${TmpFile}_python" | wc -l ) -gt 0 ]
#       then
#         echo "Rebasing python files in directory: \"${d}\"..." >&2
# 	filter_rebase_failures "${TmpFile}_python" -b "${BaseAddress}"
# 	determine_new_base ebuild "${TmpFile}_python" "${BaseAddress}" 3
#       fi
#     fi
#   fi
# done
#
# force_reasonable_base python ebuild

if [ x${Verbose} = x-v ]
then
  echo "Saving layout to ${EPrefix}/etc/gentoo_prefix_addrspace:" >&2
  dump_basevars >&2
fi

dump_basevars > "${EPrefix}"/etc/gentoo_prefix_addrspace

echo "$0: done." >&2
echo >&2

# Clean up
cleanup

# vim: syntax=sh
