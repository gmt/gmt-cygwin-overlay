diff -urN prefix-portage-2.2.01.20271.orig/cnf/make.conf prefix-portage-2.2.01.20271/cnf/make.conf
--- prefix-portage-2.2.01.20271.orig/cnf/make.conf	2011-12-23 02:30:05.000000000 -0800
+++ prefix-portage-2.2.01.20271/cnf/make.conf	2012-03-15 12:11:41.031097000 -0700
@@ -356,3 +356,25 @@
 #                               ${PACKAGE} - see description of PORTAGE_ELOG_COMMAND
 #                               ${HOST} - FQDN of the host portage is running on
 #PORTAGE_ELOG_MAILSUBJECT="[portage] ebuild log for \${PACKAGE} on \${HOST}"
+
+# PORTAGE_HOSTNAME: this variable is used by portage internally to keep track of
+#                   different machines sharing the same portage database.  This
+#                   is only neccesary if you are running a cluster of machines
+#                   which share the same filesystem (i.e., over nfs), /and/ more
+#                   than one of those machines runs portage.  At the moment, it
+#                   is only used by the "portage master-lock" feature, which,
+#                   in turn, is only so far used by the cygwin dll protection
+#                   feature.  Therefore, in practice, almost everyone can safely
+#                   completely ignore this for now.  However, if you share a
+#                   cygwin gentoo prefix across multiple hosts, more than one of
+#                   which is allowed to run emerges, you will need to set this
+#                   variable to something other than the default.
+#
+#                   The variable can be empty, in which case portage will
+#                   automatically guess the hostname of the local machine using
+#                   the python socket.getfqdn() API; alternatively, you can
+#                   set this explicitly to anything you want -- it simply needs
+#                   to be unique for each machine in the cluster that might
+#                   run portage.  By default, it is defined to "localhost" in
+#                   make.globals.
+#PORTAGE_HOSTNAME=""
diff -urN prefix-portage-2.2.01.20271.orig/cnf/make.globals prefix-portage-2.2.01.20271/cnf/make.globals
--- prefix-portage-2.2.01.20271.orig/cnf/make.globals	2012-03-14 20:43:35.637097000 -0700
+++ prefix-portage-2.2.01.20271/cnf/make.globals	2012-03-15 10:08:52.390597000 -0700
@@ -8,7 +8,8 @@
 # **** CHANGES TO make.conf *OVERRIDE* THIS FILE ****
 # ***************************************************
 # ** Incremental Variables Accumulate Across Files **
-# **  USE, CONFIG_*, and FEATURES are incremental  **
+# **  USE, CONFIG_*, CYGDLL_PROTECT, and FEATURES  **
+# **  are incremental                              **
 # ***************************************************
 
 # When compiler flags are unset, many packages will substitute their own
@@ -113,6 +114,10 @@
 CONFIG_PROTECT="/etc"
 CONFIG_PROTECT_MASK="/etc/env.d"
 
+# Nothing is included in CYGDLL_PROTECT by default
+# These are typically added at the profile level or higher.
+CYGDLL_PROTECT=""
+
 # Disable auto-use
 USE_ORDER="env:pkg:conf:defaults:pkginternal:repo:env.d"
 
@@ -125,6 +130,17 @@
 PORTAGE_INST_UID="@rootuid@"
 PORTAGE_INST_GID="@rootgid@"
 
+# Systems in a cluster sharing var/lib/portage need to
+# set this to be empty in make.conf.  This is because
+# portage will automatically clean out stale PID's
+# from var/lib/portage/masterlock/${PORTAGE_HOSTNAME}, but
+# can only do so correctly if it can be sure those pids come
+# from the local machine.  Emptying the variable will activate
+# automatic hostname detection.  Alternatively, a hard-coded
+# hostname may be used if cluster machines have a nonshared
+# portage configuration area somewhere.
+PORTAGE_HOSTNAME="localhost"
+
 # Default PATH for ebuild env
 DEFAULT_PATH="@DEFAULT_PATH@"
 # Any extra PATHs to add to the ebuild environment's PATH (if any)
diff -urN prefix-portage-2.2.01.20271.orig/man/emerge.1 prefix-portage-2.2.01.20271/man/emerge.1
--- prefix-portage-2.2.01.20271.orig/man/emerge.1	2012-03-14 20:43:35.640597000 -0700
+++ prefix-portage-2.2.01.20271/man/emerge.1	2012-03-14 20:43:36.186597000 -0700
@@ -1010,6 +1010,88 @@
 offset by Portage before they are considered.  Hence, these paths never
 contain the offset prefix, and the variables can be defined in
 offset-unaware locations, such as the profiles. 
+.SH "CYGWIN DLL PROTECTION"
+Portage for cygwin includes a feature called "cygwin dll protection", which
+roughly mirrors the functionality of the "configuration file protection"
+feature (see \fBCONFIGURATION FILES\fR above). The purpose of this feature
+is to prevent new package installs from crashing portage when replacing
+files such as .dll's which are currently in use by portage.
+.LP
+This is necessary due to a rather inconvenient limitation of the cygwin
+environment, which is necessary, in turn, due to yet another rather inconvenient
+limitation of Microsoft Windows. A full explanation is beyond the scope of
+this document, but the problem has to do with the way cygwin's implementation of
+the UNIX fork() API works, and idiocyncracies of the Windows platform's mapping
+of executable code into the so-called 'virtual memory address space.'
+Regardless of the etiology, the symptomoatology is brutally noticeable and
+readily explained:
+.LP
+If a cygwin program (such as python.exe, and hence, cygwin portage) is
+running, and we replace any execuable (again, including .dll files) which that
+program may be using, then although nothing may happen right away, as soon as
+that program attempts to call the fork() API, the program will almost certainly
+crash. This is normally not a problem in cygwin because cygwin includes an
+installation utility, 'setup.exe,' which is not itself a cygwin program (it
+is instead just a regular Windows GUI program).
+.LP
+Note that there is a second problem in cygwin which will cause crashes with
+errors about address space mapping, immediately upon program invocation.
+Although this problem is very closely related to the problem with
+replacing executables while a program is running, it is
+technically distinct and arises from different causes. The "cygwin dll
+protection" feature is only intended to solve the replacement problem (a full
+solution to the rebasing problem is still under development, but see the
+cygwin overlay's \fBprofile.bashrc\fR file for its interim pseudo\-solution.
+.LP
+When Portage installs a file that it determines to require protection (more on
+how this determination is made follows) existing files will not be overwritten.
+If a file of the same name already exists, Portage will change the name of the
+to\-be\-installed file from 'foo' to '._cygdll_foo'. If '._cygdll_foo'
+already exists, it will be overwritten. The files will later have to
+be moved to their final destination 'foo' if they are to be used. When in this
+state, the files can be said to be in 'cygwin\-dll\-protection\-limbo'.
+.LP
+Files can be explicitly protected using the \fICYGDLL_PROTECT\fR variable,
+normally defined in make.globals. Note that any file can be protected in this way,
+but it only really makes sense to protect .dll or .exe files (unless a program is
+loading files with other names into its address-space, but this is very unusual).
+The \fICYGDLL_PROTECT\fR variable, like the \fICONFIG_PROTECT\fR variable,
+is relative to the \fIEPREFIX\fR in offset (prefix) portage installations, and
+is cumulative, so that the filenames found in the various locations portage
+searches for it (the same places it looks for \fICONFIG_PROTECT\fR, including the
+environment, profile, and so on) are aggregated. Unlike \fICONFIG_PROTECT\fR,
+which can contain files and directories (and usually only contains the latter),
+\fICYGDLL_PROTECT\fR only contains file-names. Placing directory names into it
+has not been tested as of this writing and is therefore very likely to cause
+problems or trigger bugs.
+.LP
+Unfortunately, unlike \fICONFIG_PROTECT\fR, \fICYGDLL_PROTECT\fR lacks any means
+to "deactivate" the protections (in other words, there is no
+\fICYGDLL_PROTECT_MASK\fR variable). The lack of such a means, combined with
+the facts that there is no way to turn off cygwin dll protection globally,
+and that protections are aggregated across various files, means that effectively,
+deactivating the feature is all but impossible. This is simply a bug; there
+are perfectly legitimate reasons to want to not use this feature (i.e., when
+targeting a chained prefix). In the future, something will need to be done about
+this, but for now, we can only offer our apologies. You will need to find all
+the \fICYGDLL_PROTECT\fR usages across your various portage configuration files
+and empty them out to deactivate the feature.
+.LP
+In addition to deferring the overwriting of protected files, Portage should not
+delete any protected files when a package is unmerged. The exact handling of
+this scenario has not yet been worked out. At the moment, Portage leaves the
+files around(?), but in the future, something more sophisticated will need to be
+done. Most likely, the behavior will be to create an empty '._cygdll_foo'
+file which will serve as a hint to the administrator (or cygdll\-update)
+that the file should be removed.
+.LP
+A tool, \fBcygdll\-update\fR is available to aid in the merging of files in
+cygwin\-dll\-protection\-limbo. The tool will wait (forever, if need be)
+for all running portage instances to terminate, and then automagically
+find all in\-limbo files and move them to their final destinations. In the
+future, some means may be provided to do this automatically, but don't hold
+your breath.  If portage were to invoke cygdll-update itself, it would
+trigger the very conditions cygwin dll protection is designed to avoid.
 .SH "REPORTING BUGS"
 Please report any bugs you encounter through our website:
 .LP
diff -urN prefix-portage-2.2.01.20271.orig/man/make.conf.5 prefix-portage-2.2.01.20271/man/make.conf.5
--- prefix-portage-2.2.01.20271.orig/man/make.conf.5	2012-03-14 20:43:33.502097000 -0700
+++ prefix-portage-2.2.01.20271/man/make.conf.5	2012-03-15 09:53:30.517597000 -0700
@@ -151,6 +151,14 @@
 This variable is passed by the \fIebuild scripts\fR to the \fIconfigure\fR
 as \fI\-\-target=${CTARGET}\fR only if it is defined.
 .TP
+\fBCYGDLL_PROTECT\fR = \fI[space delimited list of files]\fR
+All files defined here will have "cygwin dll protection"
+enabled for them. See the \fBCYGWIN DLL PROTECTION\fR section
+of \fBemerge\fR(1) for more information.
+Note that if an offset prefix (\fBEPREFIX\fR) is activated, all paths defined
+in \fBCYGDLL_PROTECT\fR are prefixed by Portage with the offset before
+they are used.
+.TP
 \fBDISTDIR\fR = \fI[path]\fR
 Defines the location of your local source file repository. After packages
 are built, it is safe to remove any and all files from this directory since
@@ -743,6 +751,28 @@
 The command used by \fBrepoman\fR(1) to sign manifests when \fBsign\fR is
 in \fBFEATURES\fR.
 .TP
+.B PORTAGE_HOSTNAME
+In order to prevent portage from running at the same time as certain
+programs (to date, \fBcygdll-update\fR(1) is the only one) , it is
+necessary to distinguish between different machines which may share
+the same portage database.  To do so, portage can attempt to use the
+fully qualified domain name as detected by the python
+socket.getfqdn() API.  In certain cases, this will not have
+the intended result (in the case of a machine with a dynamic IP, for
+example, it could result in a buildup of crufty little files in
+\\${EROOT}/var/lib/portage/masterlock, which might, in turn, cause portage
+to take a long time to start up).  By setting this to something that
+uniquely identifies the machine (it is not important for it to be a real
+DNS name), this automatic detection can be overridden.
+.br
+If you are sure that your filesystem will never be shared, it is safe
+(and arguably prefereable) to use "localhost".  Since this is by
+far the most common scenario, it has been made the default.  To
+override it, either add a fixed PORTAGE_HOSTNAME, or,
+to activate the automatic detection feature, an empty PORTAGE_HOSTNAME
+to make.conf.  Unless you run portage on a "cluster" of machines with a
+shared filesystem, the default should be fine.
+.TP
 \fBPORTAGE_IONICE_COMMAND\fR = \fI[ionice command string]\fR
 This variable should contain a command for portage to call in order
 to adjust the io priority of portage and it's subprocesses. The command
diff -urN prefix-portage-2.2.01.20271.orig/pym/_emerge/actions.py prefix-portage-2.2.01.20271/pym/_emerge/actions.py
--- prefix-portage-2.2.01.20271.orig/pym/_emerge/actions.py	2012-03-14 20:43:35.643597000 -0700
+++ prefix-portage-2.2.01.20271/pym/_emerge/actions.py	2012-03-14 20:43:36.190097000 -0700
@@ -1455,7 +1455,7 @@
 		myvars = list(settings)
 	else:
 		myvars = ['GENTOO_MIRRORS', 'CONFIG_PROTECT', 'CONFIG_PROTECT_MASK',
-		          'PORTDIR', 'DISTDIR', 'PKGDIR', 'PORTAGE_TMPDIR',
+		          'PORTDIR', 'DISTDIR', 'PKGDIR', 'PORTAGE_TMPDIR', 'CYGDLL_PROTECT',
 		          'PORTDIR_OVERLAY', 'PORTAGE_BUNZIP2_COMMAND',
 		          'PORTAGE_BZIP2_COMMAND',
 		          'USE', 'CHOST', 'CFLAGS', 'CXXFLAGS',
@@ -2532,6 +2532,9 @@
 	chk_updated_cfg_files(settings["EROOT"],
 		portage.util.shlex_split(settings.get("CONFIG_PROTECT", "")))
 
+	chk_updated_cygdll_files(settings["EROOT"],
+		portage.util.shlex_split(settings.get("CYGDLL_PROTECT", "")))
+
 	if myaction != "metadata":
 		postsync = os.path.join(settings["PORTAGE_CONFIGROOT"],
 			portage.USER_CONFIG_PATH, "bin", "post_sync")
@@ -3072,6 +3075,22 @@
 				+ " section of the " + bold("emerge"))
 		print(" "+yellow("*")+" man page to learn how to update config files.")
 
+def chk_updated_cygdll_files(eroot, cygdll_protect):
+	result = portage.util.find_updated_cygdll_files(eroot, cygdll_protect)
+
+	for x in result:
+		writemsg_level("\n %s " % (colorize("WARN", "* IMPORTANT:"),),
+			level=logging.INFO, noiselevel=-1)
+		writemsg_level("file '%s' is in cygwin-dll-protection-limbo.\n" % x,
+			level=logging.INFO, noiselevel=-1)
+	if result:
+		print(" "+yellow("*")+" Run '" + bold("cygdll-update") + \
+					"' to fully merge files held in CYGDLL_PROTECT 'limbo'")
+		print(" "+yellow("*")+" To learn why you suffer" + \
+					" from this affliction, read the")
+		print(" "+yellow("*")+" " + colorize("INFORM","CYGWIN DLL PROTECTION") + \
+					" section of the " + bold("emerge") + " man page.")
+
 def display_news_notification(root_config, myopts):
 	if "news" not in root_config.settings.features:
 		return
diff -urN prefix-portage-2.2.01.20271.orig/pym/_emerge/main.py prefix-portage-2.2.01.20271/pym/_emerge/main.py
--- prefix-portage-2.2.01.20271.orig/pym/_emerge/main.py	2012-03-14 20:43:35.647597000 -0700
+++ prefix-portage-2.2.01.20271/pym/_emerge/main.py	2012-03-14 20:43:36.194597000 -0700
@@ -39,8 +39,9 @@
 
 from _emerge.actions import action_config, action_sync, action_metadata, \
 	action_regen, action_search, action_uninstall, action_info, action_build, \
-	adjust_configs, chk_updated_cfg_files, display_missing_pkg_set, \
-	display_news_notification, getportageversion, load_emerge_config
+	adjust_configs, chk_updated_cfg_files, chk_updated_cygdll_files, \
+	display_missing_pkg_set, display_news_notification, getportageversion, \
+	load_emerge_config
 import _emerge
 from _emerge.emergelog import emergelog
 from _emerge._flush_elog_mod_echo import _flush_elog_mod_echo
@@ -357,6 +358,8 @@
 	settings.lock()
 
 	config_protect = shlex_split(settings.get("CONFIG_PROTECT", ""))
+	cygdll_protect = shlex_split(settings.get("CYGDLL_PROTECT", ""))
+
 	infodirs = settings.get("INFOPATH","").split(":") + \
 		settings.get("INFODIR","").split(":")
 
@@ -393,6 +396,7 @@
 				vardbapi.unlock()
 
 	chk_updated_cfg_files(settings['EROOT'], config_protect)
+	chk_updated_cygdll_files(settings['EROOT'], cygdll_protect)
 
 	display_news_notification(root_config, myopts)
 	if retval in (None, os.EX_OK) or (not "--pretend" in myopts):
@@ -1548,6 +1552,16 @@
 
 	return bool(ignored_repos)
 
+def cygdll_protect_check(trees):
+	for root, root_trees in trees.items():
+		settings = root_trees["root_config"].settings
+		if not settings.get("CYGDLL_PROTECT"):
+			msg = "!!! CYGDLL_PROTECT is empty"
+			if settings["ROOT"] != "/":
+				msg + "for '%s'" % root
+			msg += "\n"
+			writemsg_level(msg, level=logging.WARN, noiselevel=-1)
+
 def config_protect_check(trees):
 	for root, root_trees in trees.items():
 		settings = root_trees["root_config"].settings
@@ -1676,6 +1690,8 @@
 			repo_name_check(trees)
 		repo_name_duplicate_check(trees)
 		config_protect_check(trees)
+		cygdll_protect_check(trees)
+
 	check_procfs()
 
 	if "getbinpkg" in settings.features:
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/__init__.py prefix-portage-2.2.01.20271/pym/portage/__init__.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/__init__.py	2012-03-14 20:43:35.651097000 -0700
+++ prefix-portage-2.2.01.20271/pym/portage/__init__.py	2012-03-14 20:43:36.197597000 -0700
@@ -99,7 +99,8 @@
 		'portage.util:atomic_ofstream,apply_secpass_permissions,' + \
 			'apply_recursive_permissions,dump_traceback,getconfig,' + \
 			'grabdict,grabdict_package,grabfile,grabfile_package,' + \
-			'map_dictlist_vals,new_protect_filename,normalize_path,' + \
+			'map_dictlist_vals,new_cygdllprotect_filename,' + \
+			'new_protect_filename,normalize_path,' + \
 			'pickle_read,pickle_write,stack_dictlist,stack_dicts,' + \
 			'stack_lists,unique_array,varexpand,writedict,writemsg,' + \
 			'writemsg_stdout,write_atomic',
@@ -130,7 +131,7 @@
 		EBUILD_SH_BINARY, SANDBOX_BINARY, BASH_BINARY, \
 		MOVE_BINARY, PRELINK_BINARY, WORLD_FILE, MAKE_CONF_FILE, MAKE_DEFAULTS_FILE, \
 		DEPRECATED_PROFILE_FILE, USER_VIRTUALS_FILE, EBUILD_SH_ENV_FILE, \
-		INVALID_ENV_FILE, CUSTOM_MIRRORS_FILE, CONFIG_MEMORY_FILE,\
+		INVALID_ENV_FILE, CUSTOM_MIRRORS_FILE, CONFIG_MEMORY_FILE, CYGDLL_MEMORY_FILE, \
 		INCREMENTALS, EAPI, MISC_SH_BINARY, REPO_NAME_LOC, REPO_NAME_FILE, \
 		EPREFIX, EPREFIX_LSTRIP, rootuid
 
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/const.py prefix-portage-2.2.01.20271/pym/portage/const.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/const.py	2012-03-14 20:43:35.652597000 -0700
+++ prefix-portage-2.2.01.20271/pym/portage/const.py	2012-03-14 21:24:03.373780300 -0700
@@ -55,6 +55,8 @@
 WORLD_FILE               = PRIVATE_PATH + "/world"
 WORLD_SETS_FILE          = PRIVATE_PATH + "/world_sets"
 CONFIG_MEMORY_FILE       = PRIVATE_PATH + "/config"
+CYGDLL_MEMORY_FILE       = PRIVATE_PATH + "/cygdll"
+PORTAGE_MASTER_LOCKDIR   = PRIVATE_PATH + "/masterlock"
 NEWS_LIB_PATH            = "var/lib/gentoo"
 
 # these variables get EPREFIX prepended automagically when they are
@@ -114,6 +116,7 @@
 INCREMENTALS             = ("USE", "USE_EXPAND", "USE_EXPAND_HIDDEN",
                            "FEATURES", "ACCEPT_KEYWORDS",
                            "CONFIG_PROTECT_MASK", "CONFIG_PROTECT",
+                           "CYGDLL_PROTECT",
                            "PRELINK_PATH", "PRELINK_PATH_MASK",
                            "PROFILE_ONLY_VARIABLES")
 EBUILD_PHASES            = ("pretend", "setup", "unpack", "prepare", "configure",
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/dbapi/_MergeProcess.py prefix-portage-2.2.01.20271/pym/portage/dbapi/_MergeProcess.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/dbapi/_MergeProcess.py	2012-03-14 20:43:35.654597000 -0700
+++ prefix-portage-2.2.01.20271/pym/portage/dbapi/_MergeProcess.py	2012-03-14 20:43:36.201597000 -0700
@@ -213,7 +213,8 @@
 			else:
 				rval = mylink.merge(self.pkgloc, self.infloc,
 					myebuild=self.myebuild, mydbapi=self.mydbapi,
-					prev_mtimes=self.prev_mtimes, counter=counter)
+					prev_mtimes=self.prev_mtimes,
+					counter=counter)
 		except SystemExit:
 			raise
 		except:
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/dbapi/bintree.py prefix-portage-2.2.01.20271/pym/portage/dbapi/bintree.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/dbapi/bintree.py	2012-03-14 20:43:35.658097000 -0700
+++ prefix-portage-2.2.01.20271/pym/portage/dbapi/bintree.py	2012-03-14 20:43:36.204097000 -0700
@@ -299,7 +299,7 @@
 			self._pkgindex_header_keys = set([
 				"ACCEPT_KEYWORDS", "ACCEPT_LICENSE",
 				"ACCEPT_PROPERTIES", "CBUILD",
-				"CONFIG_PROTECT", "CONFIG_PROTECT_MASK", "FEATURES",
+				"CONFIG_PROTECT", "CONFIG_PROTECT_MASK", "CYGDLL_PROTECT", "FEATURES",
 				"GENTOO_MIRRORS", "INSTALL_MASK", "SYNC", "USE", "EPREFIX"])
 			self._pkgindex_default_pkg_data = {
 				"BUILD_TIME"         : "",
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/dbapi/vartree.py prefix-portage-2.2.01.20271/pym/portage/dbapi/vartree.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/dbapi/vartree.py	2012-03-14 20:43:35.664597000 -0700
+++ prefix-portage-2.2.01.20271/pym/portage/dbapi/vartree.py	2012-03-15 12:22:12.026097000 -0700
@@ -23,7 +23,7 @@
 	'portage.update:fixdbentries',
 	'portage.util:apply_secpass_permissions,ConfigProtect,ensure_dirs,' + \
 		'writemsg,writemsg_level,write_atomic,atomic_ofstream,writedict,' + \
-		'grabdict,normalize_path,new_protect_filename',
+		'grabdict,normalize_path,new_protect_filename,new_cygdllprotect_filename',
 	'portage.util.digraph:digraph',
 	'portage.util.env_update:env_update',
 	'portage.util.listdir:dircache,listdir',
@@ -39,7 +39,7 @@
 	'tarfile',
 )
 
-from portage.const import CACHE_PATH, CONFIG_MEMORY_FILE, \
+from portage.const import CACHE_PATH, CONFIG_MEMORY_FILE, CYGDLL_MEMORY_FILE, \
 	PORTAGE_PACKAGE_ATOM, PRIVATE_PATH, VDB_PATH, EPREFIX, EPREFIX_LSTRIP, BASH_BINARY
 from portage.const import _ENABLE_DYN_LINK_MAP, _ENABLE_PRESERVE_LIBS
 from portage.dbapi import dbapi
@@ -151,6 +151,7 @@
 		self._lock_count = 0
 
 		self._conf_mem_file = self._eroot + CONFIG_MEMORY_FILE
+		self._cygdll_mem_file = self._eroot + CYGDLL_MEMORY_FILE
 		self._fs_lock_obj = None
 		self._fs_lock_count = 0
 
@@ -1485,13 +1486,18 @@
 			portage.util.shlex_split(
 				self.settings.get("CONFIG_PROTECT", "")),
 			portage.util.shlex_split(
-				self.settings.get("CONFIG_PROTECT_MASK", "")))
+				self.settings.get("CONFIG_PROTECT_MASK", "")),
+			portage.util.shlex_split(
+				self.settings.get("CYGDLL_PROTECT", "")))
 
 		return self._protect_obj
 
 	def isprotected(self, obj):
 		return self._get_protect_obj().isprotected(obj)
 
+	def iscygdllprotected(self, obj):
+		return self._get_protect_obj().iscygdllprotected(obj)
+
 	def updateprotect(self):
 		self._get_protect_obj().updateprotect()
 
@@ -2040,9 +2046,11 @@
 				others_in_slot.append(dblink(self.cat, catsplit(cur_cpv)[1],
 					settings=self.settings,
 					vartree=self.vartree, treetype="vartree", pipe=self._pipe))
-
 		cfgfiledict = grabdict(self.vartree.dbapi._conf_mem_file)
+		cygdlldict = grabdict(self.vartree.dbapi._cygdll_mem_file)
+
 		stale_confmem = []
+		stale_cygdllmem = []
 		protected_symlinks = {}
 
 		unmerge_orphans = "unmerge-orphans" in self.settings.features
@@ -2203,8 +2211,11 @@
 					if is_owned:
 						show_unmerge("---", unmerge_desc["replaced"], file_type, obj)
 						continue
-					elif relative_path in cfgfiledict:
-						stale_confmem.append(relative_path)
+					else:
+						if relative_path in cfgfiledict:
+							stale_confmem.append(relative_path)
+						if relative_path in cygdlldict:
+							stale_cygdllmem.append(relative_path)
 				# next line includes a tweak to protect modules from being unmerged,
 				# but we don't protect modules from being overwritten if they are
 				# upgraded. We effectively only want one half of the config protection
@@ -2371,6 +2382,12 @@
 				del cfgfiledict[filename]
 			writedict(cfgfiledict, self.vartree.dbapi._conf_mem_file)
 
+		# Remove stale entries from cygdll memory.
+		if stale_cygdllmem:
+			for filename in stale_cygdllmem:
+				del cygdlldict[filename]
+			writedict(cygdlldict, self.vartree.dbapi._cygdll_mem_file)
+
 		#remove self from vartree database so that our own virtual gets zapped if we're the last node
 		self.vartree.zap(self.mycpv)
 
@@ -3830,6 +3847,7 @@
 		self.vartree.dbapi._fs_lock()
 		try:
 			cfgfiledict = grabdict(self.vartree.dbapi._conf_mem_file)
+			cygdlldict = grabdict(self.vartree.dbapi._cygdll_mem_file)
 			if "NOCONFMEM" in self.settings:
 				cfgfiledict["IGNORE"]=1
 			else:
@@ -3844,7 +3862,7 @@
 					cfgfiledict["IGNORE"] = 1
 					break
 
-			rval = self._merge_contents(srcroot, destroot, cfgfiledict)
+			rval = self._merge_contents(srcroot, destroot, cfgfiledict, cygdlldict)
 			if rval != os.EX_OK:
 				return rval
 		finally:
@@ -4091,7 +4109,7 @@
 
 		return backup_p
 
-	def _merge_contents(self, srcroot, destroot, cfgfiledict):
+	def _merge_contents(self, srcroot, destroot, cfgfiledict, cygdlldict):
 
 		cfgfiledict_orig = cfgfiledict.copy()
 
@@ -4118,7 +4136,7 @@
 		# we do a first merge; this will recurse through all files in our srcroot but also build up a
 		# "second hand" of symlinks to merge later
 		if self.mergeme(srcroot, destroot, outfile, secondhand,
-			self.settings["EPREFIX"].lstrip(os.sep), cfgfiledict, mymtime):
+			self.settings["EPREFIX"].lstrip(os.sep), cfgfiledict, mymtime, cygdlldict):
 			return 1
 
 		# now, it's time for dealing our second hand; we'll loop until we can't merge anymore.	The rest are
@@ -4130,7 +4148,7 @@
 
 			thirdhand = []
 			if self.mergeme(srcroot, destroot, outfile, thirdhand,
-				secondhand, cfgfiledict, mymtime):
+				secondhand, cfgfiledict, mymtime, cygdlldict):
 				return 1
 
 			#swap hands
@@ -4144,7 +4162,7 @@
 		if len(secondhand):
 			# force merge of remaining symlinks (broken or circular; oh well)
 			if self.mergeme(srcroot, destroot, outfile, None,
-				secondhand, cfgfiledict, mymtime):
+				secondhand, cfgfiledict, mymtime, cygdlldict):
 				return 1
 
 		#restore umask
@@ -4165,7 +4183,7 @@
 
 		return os.EX_OK
 
-	def mergeme(self, srcroot, destroot, outfile, secondhand, stufftomerge, cfgfiledict, thismtime):
+	def mergeme(self, srcroot, destroot, outfile, secondhand, stufftomerge, cfgfiledict, thismtime, cygdlldict):
 		"""
 		
 		This function handles actual merging of the package contents to the livefs.
@@ -4186,6 +4204,8 @@
 		@type cfgfiledict: Dictionary
 		@param thismtime: The current time (typically long(time.time())
 		@type thismtime: Long
+		@param cygdlldict: { File:md5 } mapping for cygdll_protected files
+		@type cygdlldict: Dictionary
 		@rtype: None or Boolean
 		@returns:
 		1. True on failure
@@ -4203,6 +4223,8 @@
 		destroot = normalize_path(destroot).rstrip(sep) + sep
 		calc_prelink = "prelink-checksums" in self.settings.features
 
+		orig_cygdlldict = cygdlldict.copy()
+
 		protect_if_modified = \
 			"config-protect-if-modified" in self.settings.features and \
 			self._installed_instance is not None
@@ -4415,7 +4437,7 @@
 				outfile.write("dir "+myrealdest+"\n")
 				# recurse and merge this directory
 				if self.mergeme(srcroot, destroot, outfile, secondhand,
-					join(offset, x), cfgfiledict, thismtime):
+					join(offset, x), cfgfiledict, thismtime, cygdlldict):
 					return 1
 			elif stat.S_ISREG(mymode):
 				# we are merging a regular file
@@ -4426,6 +4448,7 @@
 				zing = "!!!"
 				mymtime = None
 				protected = self.isprotected(mydest)
+				cygdllprotected = self.iscygdllprotected(mydest)
 				if mydmode != None:
 					# destination file exists
 					
@@ -4456,8 +4479,8 @@
 									inst_info = self._installed_instance.getcontents()[contents_key]
 									if inst_info[0] == "obj" and inst_info[2] == destmd5:
 										protected = False
-
 						if protected:
+							cygdllprotected = False
 							# we have a protection path; enable config file management.
 							cfgprot = 0
 							if mymd5 == destmd5:
@@ -4486,6 +4509,50 @@
 
 							if cfgprot:
 								mydest = new_protect_filename(mydest, newmd5=mymd5)
+						elif cygdllprotected:
+							# note that we don't have anything like "protect_if_modified"
+							# but we could really use something like calc_prelink (TODO)
+							# to handle rebasing.
+							cygprot = 0
+							destmd5 = perform_md5(mydest, calc_prelink=calc_prelink)
+							if mymd5 == destmd5:
+								# file already in place; simply update mtimes of destination
+								moveme = 1
+							else:
+								if mymd5 == cygdlldict.get(myrealdest, [None])[0]:
+									""" An identical update has previously been
+									merged.  Skip it."""
+									moveme = 0
+									cygprot = 0
+									mymtime = mystat[stat.ST_MTIME]
+								else:
+									moveme = 1
+									cygprot = 1
+							if moveme:
+								# merging a new cygdll so update confmem.
+								cygdlldict[myrealdest] = [mymd5]
+
+
+							elif destmd5 == cygdlldict.get(myrealdest, [None])[0]:
+								"""A previously remembered update has been merged, so it is
+								removed from cygdllmem."""
+								del cygdlldict[myrealdest]
+
+							if cygprot:
+								mydest = new_cygdllprotect_filename(mydest, newmd5=mymd5)
+
+				# once we introduce the "currently loaded dlls" heuristic
+				# CYGDLL_PROTECT offers no easy way (except, perhaps,
+				# "find / -name '_cygdll_*', but that's too slow) to
+				# find the CYGDLL_PROTECT'ed files.  for this reason we ought
+				# not to be as cavalier as we are with conffiledict. let's save
+				# our changes now, *before* anything gets merged to the fs)
+				if cygdlldict != orig_cygdlldict:
+					try:
+						writedict(cygdlldict, self.vartree.dbapi._cygdll_mem_file)
+					except InvalidLocation:
+						self.settings._init_dirs()
+						writedict(cygdlldict, self.vartree.dbapi._cygdll_mem_file)
 
 				# whether config protection or not, we merge the new file the
 				# same way.  Unless moveme=0 (blocking directory)
Binary files prefix-portage-2.2.01.20271.orig/pym/portage/package/ebuild/.config.py.swp and prefix-portage-2.2.01.20271/pym/portage/package/ebuild/.config.py.swp differ
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/package/ebuild/_config/special_env_vars.py prefix-portage-2.2.01.20271/pym/portage/package/ebuild/_config/special_env_vars.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/package/ebuild/_config/special_env_vars.py	2012-03-14 20:43:35.666097000 -0700
+++ prefix-portage-2.2.01.20271/pym/portage/package/ebuild/_config/special_env_vars.py	2012-03-14 23:37:53.955075400 -0700
@@ -150,7 +150,7 @@
 # portage config variables and variables set directly by portage
 environ_filter += [
 	"ACCEPT_CHOSTS", "ACCEPT_KEYWORDS", "ACCEPT_PROPERTIES", "AUTOCLEAN",
-	"CLEAN_DELAY", "COLLISION_IGNORE", "CONFIG_PROTECT",
+	"CLEAN_DELAY", "COLLISION_IGNORE", "CONFIG_PROTECT", "CYGDLL_PROTECT",
 	"CONFIG_PROTECT_MASK", "EGENCACHE_DEFAULT_OPTS", "EMERGE_DEFAULT_OPTS",
 	"EMERGE_LOG_DIR",
 	"EMERGE_WARNING_DELAY",
@@ -167,6 +167,7 @@
 	"PORTAGE_FETCH_CHECKSUM_TRY_MIRRORS", "PORTAGE_FETCH_RESUME_MIN_SIZE",
 	"PORTAGE_GPG_DIR",
 	"PORTAGE_GPG_KEY", "PORTAGE_GPG_SIGNING_COMMAND",
+	"PORTAGE_HOSTNAME",
 	"PORTAGE_IONICE_COMMAND",
 	"PORTAGE_PACKAGE_EMPTY_ABORT",
 	"PORTAGE_REPO_DUPLICATE_WARN",
@@ -187,6 +188,7 @@
 # settings.
 global_only_vars = frozenset([
 	"CONFIG_PROTECT",
+	"PORTAGE_HOSTNAME",
 ])
 
 default_globals = {
@@ -199,4 +201,4 @@
 
 # To enhance usability, make some vars case insensitive
 # by forcing them to lower case.
-case_insensitive_vars = ('AUTOCLEAN', 'NOCOLOR',)
+case_insensitive_vars = ('AUTOCLEAN', 'NOCOLOR', 'PORTAGE_HOSTNAME')
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/package/ebuild/config.py prefix-portage-2.2.01.20271/pym/portage/package/ebuild/config.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/package/ebuild/config.py	2012-02-19 02:09:03.000000000 -0800
+++ prefix-portage-2.2.01.20271/pym/portage/package/ebuild/config.py	2012-03-15 11:53:43.973097000 -0700
@@ -14,6 +14,7 @@
 import re
 import sys
 import warnings
+from socket import getfqdn
 
 from _emerge.Package import Package
 import portage
@@ -24,7 +25,7 @@
 	load_mod, os, selinux, _unicode_decode
 from portage.const import CACHE_PATH, \
 	DEPCACHE_PATH, INCREMENTALS, MAKE_CONF_FILE, \
-	MODULES_FILE_PATH, \
+	MODULES_FILE_PATH, PORTAGE_MASTER_LOCKDIR, \
 	PRIVATE_PATH, PROFILE_PATH, USER_CONFIG_PATH, \
 	USER_VIRTUALS_FILE
 from portage.dbapi import dbapi
@@ -726,6 +727,10 @@
 					self["USERLAND"] = "GNU"
 				self.backup_changes("USERLAND")
 
+			if "PORTAGE_HOSTNAME" not in self or self["PORTAGE_HOSTNAME"] == "":
+				self["PORTAGE_HOSTNAME"] = getfqdn()
+				self.backup_changes("PORTAGE_HOSTNAME")
+
 			default_inst_ids = {
 				"PORTAGE_INST_GID": "0",
 				"PORTAGE_INST_UID": "0",
@@ -853,6 +858,8 @@
 			"tmp"             : (         -1, 0o1777,  0,  True),
 			"var/tmp"         : (         -1, 0o1777,  0,  True),
 			PRIVATE_PATH      : (portage_gid, 0o2750, 0o2, False),
+			PORTAGE_MASTER_LOCKDIR \
+			                  : (portage_gid, 0o2750, 0o2, False),
 			CACHE_PATH        : (portage_gid,  0o755, 0o2, False)
 		}
 
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/util/__init__.py prefix-portage-2.2.01.20271/pym/portage/util/__init__.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/util/__init__.py	2012-03-14 20:43:35.672597000 -0700
+++ prefix-portage-2.2.01.20271/pym/portage/util/__init__.py	2012-03-14 20:43:36.218597000 -0700
@@ -4,12 +4,13 @@
 __all__ = ['apply_permissions', 'apply_recursive_permissions',
 	'apply_secpass_permissions', 'apply_stat_permissions', 'atomic_ofstream',
 	'cmp_sort_key', 'ConfigProtect', 'dump_traceback', 'ensure_dirs',
-	'find_updated_config_files', 'getconfig', 'getlibpaths', 'grabdict',
-	'grabdict_package', 'grabfile', 'grabfile_package', 'grablines',
-	'initialize_logger', 'LazyItemsDict', 'map_dictlist_vals',
-	'new_protect_filename', 'normalize_path', 'pickle_read', 'stack_dictlist',
-	'stack_dicts', 'stack_lists', 'unique_array', 'unique_everseen', 'varexpand',
-	'write_atomic', 'writedict', 'writemsg', 'writemsg_level', 'writemsg_stdout']
+	'find_updated_config_files', 'find_updated_cygdll_files', 'getconfig',
+	'getlibpaths', 'grabdict', 'grabdict_package', 'grabfile',
+	'grabfile_package', 'grablines', 'initialize_logger', 'LazyItemsDict',
+	'map_dictlist_vals', 'new_cygdllprotect_filename', 'new_protect_filename',
+	'normalize_path', 'pickle_read', 'stack_dictlist', 'stack_dicts',
+	'stack_lists', 'unique_array', 'unique_everseen', 'varexpand',
+	'write_atomic', 'writedict', 'writemsg', 'writemsg_level','writemsg_stdout']
 
 from copy import deepcopy
 import errno
@@ -45,7 +46,7 @@
 from portage.localization import _
 from portage.proxy.objectproxy import ObjectProxy
 from portage.cache.mappings import UserDict
-from portage.const import EPREFIX
+from portage.const import EPREFIX, CYGDLL_MEMORY_FILE
 
 noiselimit = 0
 
@@ -1416,15 +1417,16 @@
 			return result
 
 class ConfigProtect(object):
-	def __init__(self, myroot, protect_list, mask_list):
+	def __init__(self, myroot, protect_list, mask_list, cygdllprotect_list = []):
 		self.myroot = myroot
 		self.protect_list = protect_list
 		self.mask_list = mask_list
+		self.cygdllprotect_list = cygdllprotect_list
 		self.updateprotect()
 
 	def updateprotect(self):
-		"""Update internal state for isprotected() calls.  Nonexistent paths
-		are ignored."""
+		"""Update internal state for isprotected() and iscygdllprotected() calls.
+		Nonexistent paths are ignored."""
 
 		os = _os_merge
 
@@ -1457,6 +1459,18 @@
 			except OSError:
 				# If it doesn't exist, there's no need to mask it.
 				pass
+		
+		self.cygdllprotect = []
+		for x in self.cygdllprotect_list:
+			ppath = normalize_path(
+				os.path.join(self.myroot, x.lstrip(os.path.sep)))
+			try:
+				if stat.S_ISREG(os.stat(ppath).st_mode):
+					self.cygdllprotect.append(ppath)
+			except OSError:
+				# if it doesn't exist (or it exists but is not a regular file),
+				# there's no need to protect it.
+				pass
 
 	def isprotected(self, obj):
 		"""Returns True if obj is protected, False otherwise.  The caller must
@@ -1492,6 +1506,11 @@
 						masked = len(pmpath)
 		return protected > masked
 
+	def iscygdllprotected(self, obj):
+		"""Returns True if obj is cygdll_protected, False otherwise.  The caller must
+		ensure that obj is normalized with a single leading slash."""
+		return (obj in self.cygdllprotect)
+
 def new_protect_filename(mydest, newmd5=None, force=False):
 	"""Resolves a config-protect filename for merging, optionally
 	using the last filename if the md5 matches. If force is True,
@@ -1544,6 +1563,53 @@
 				return old_pfile
 	return new_pfile
 
+def new_cygdllprotect_filename(mydest, newmd5=None, force=False):
+	"""Resolves a cygdll-protect filename for merging, optionally
+	using the last filename if the md5 matches. If force is True,
+	then a new filename will be generated even if mydest does not
+	exist yet.  newmd5 is not used but is kept for symmetry
+	"""
+	
+	# cygdll protection filename format:
+	# foo.dll => _cygdll_foo.dll
+
+	# unlike with config files, there is no need to support multiple layers of
+	# pending changes, so no numbers are used. 
+	
+	os = _os_merge
+
+	old_pfile = False
+
+	if not force and \
+		not os.path.exists(mydest):
+		return mydest
+
+	real_filename = os.path.basename(mydest)
+	real_dirname  = os.path.dirname(mydest)
+
+	return normalize_path(os.path.join(real_dirname, "_cygdll_" + real_filename))
+
+def find_updated_cygdll_files(target_root, cygdll_protect):
+	"""
+	Given a root (prefix), and a list of unprefixed paths (such as are to be found in
+	CYGDLL_PROTECT), looks for dlls with pending cygdll_protected updates merged into
+	the filesystem.  It will check everything in cygdll_protect manually and also
+	everything in the eprefix + '/var/lib/portage/cygdll' database.  Returns a regular
+	list (unlike, confusingly, find_updated_config_files) of fully-qualified paths.
+	"""
+	os = _os_merge
+
+	candidates = [ os.path.join(target_root, os.path.relpath(x, os.sep)) \
+		       for x in cygdll_protect ]
+
+	cygdll_mem_file = os.path.join(target_root, CYGDLL_MEMORY_FILE);
+	cygdll_dict = grabdict(cygdll_mem_file)
+	candidates.extend(cygdll_dict.keys())
+
+	return [x for (x,p) in [(x,new_cygdllprotect_filename(x, None, True)) \
+				for x in candidates] \
+		if os.path.exists(p)]
+
 def find_updated_config_files(target_root, config_protect):
 	"""
 	Return a tuple of configuration files that needs to be updated.
diff -urN prefix-portage-2.2.01.20271.orig/pym/portage/util/env_update.py prefix-portage-2.2.01.20271/pym/portage/util/env_update.py
--- prefix-portage-2.2.01.20271.orig/pym/portage/util/env_update.py	2012-03-14 20:43:35.675097000 -0700
+++ prefix-portage-2.2.01.20271/pym/portage/util/env_update.py	2012-03-14 20:43:36.220597000 -0700
@@ -104,7 +104,7 @@
 	fns = templist
 	del templist
 
-	space_separated = set(["CONFIG_PROTECT", "CONFIG_PROTECT_MASK"])
+	space_separated = set(["CONFIG_PROTECT", "CONFIG_PROTECT_MASK", "CYGDLL_PROTECT"])
 	colon_separated = set(["ADA_INCLUDE_PATH", "ADA_OBJECTS_PATH",
 		"CLASSPATH", "INFODIR", "INFOPATH", "KDEDIRS", "LDPATH", "MANPATH",
 		  "PATH", "PKG_CONFIG_PATH", "PRELINK_PATH", "PRELINK_PATH_MASK",
